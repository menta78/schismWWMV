#include "wwm_functions.h"
      SUBROUTINE COMPUTE_DIVERGENCE_LH_STRESS(TheDiv)
      USE DATAPOOL
      implicit none
      real(rkind), intent(inout) :: TheDiv(MNP)
      real(rkind) :: U_X(MNP), U2(MNP), INPUT(MNP)
      integer IP, ID, IS
      REAL(rkind) :: COSE2, SINE2, WN, ELOC
      REAL(rkind) :: ACLOC(MSC,MDC)
      DO IP = 1, MNP
        ACLOC = AC2(IP,:,:)
        DO ID = 1, MDC
          DO IS = 2, MSC
            ELOC  = DS_INCR(IS)*DDIR*(SPSIG(IS)*ACLOC(IS,ID)+SPSIG(IS-1)*ACLOC(IS-1,ID))
            COSE2 = COS(SPDIR(ID))**TWO
            SINE2 = SIN(SPDIR(ID))**TWO
            COSI2 = COS(SPDIR(ID)) * SIN(SPDIR(ID))
            WN    = CG(IP,IS) / ( SPSIG(IS)/WK(IP,IS) )
            RSXX(IP) = RSXX(IP)+( WN * COSE2 + WN - ONEHALF)*ELOC
            RSXY(IP) = RSXY(IP)+( WN * COSI2               )*ELOC
            RSYY(IP) = RSYY(IP)+( WN * SINE2 + WN - ONEHALF)*ELOC
          ENDDO
        ENDDO
      END DO
      CALL DIFFERENTIATE_XYDIR(RSXX,U_X, U_Y)
      INPUT=U_X
      CALL DIFFERENTIATE_XYDIR(INPUT ,U_X, U_Y)
      TheDiv=-U_X
      !
      CALL DIFFERENTIATE_XYDIR(RSXY,U_X, U_Y)
      INPUT=U_X
      CALL DIFFERENTIATE_XYDIR(INPUT ,U_X, U_Y)
      TheDiv=TheDiv-U_Y
      !
      CALL DIFFERENTIATE_XYDIR(RSXY,U_X, U_Y)
      INPUT=U_Y
      CALL DIFFERENTIATE_XYDIR(INPUT ,U_X, U_Y)
      TheDiv=TheDiv-U_X
      !
      CALL DIFFERENTIATE_XYDIR(RSYY,U_X, U_Y)
      INPUT=U_Y
      CALL DIFFERENTIATE_XYDIR(INPUT ,U_X, U_Y)
      TheDiv=TheDiv-U_Y
      END SUBROUTINE
!**********************************************************************
!*                                                                    *
!**********************************************************************
      SUBROUTINE COMPUTE_DIFF(IE, I1, UGRAD, VGRAD)
      USE DATAPOOL
      IMPLICIT NONE
      INTEGER, intent(in) :: IE, I1
      REAL(rkind), intent(inout) :: UGRAD, VGRAD
      REAL(rkind) :: h
      INTEGER :: POS_TRICK(3,2)
      POS_TRICK(1,1) = 2
      POS_TRICK(1,2) = 3
      POS_TRICK(2,1) = 3
      POS_TRICK(2,2) = 1
      POS_TRICK(3,1) = 1
      POS_TRICK(3,2) = 2
      I2=POS_TRICK(I, 1)
      I2=POS_TRICK(I, 2)
      h=(XP(I1) - XP(I2))*(YP(I3) - YP(I2)) - (YP(I1) - YP(I2))*(XP(I3) - XP(I2))
      UGRAD= (YP(I3)-YP(I2))/h
      VGRAD=-(XP(I3)-XP(I2))/h
      END SUBROUTINE
!**********************************************************************
!*                                                                    *
!**********************************************************************
      SUBROUTINE COMPUTE_SYSTEM_WAVE_SETUP(ASPAR, B, FX, FY)
      USE DATAPOOL
      IMPLICIT NONE
      real(rkind), intent(in)  :: FX(MNP), FY(MNP)
      real(rkind), intent(out) :: ASPAR(NNZ)
      real(rkind), intent(out) :: B(MNP)
      INTEGER :: POS_TRICK(3,2)
      POS_TRICK(1,1) = 2
      POS_TRICK(1,2) = 3
      POS_TRICK(2,1) = 3
      POS_TRICK(2,2) = 1
      POS_TRICK(3,1) = 1
      POS_TRICK(3,2) = 2
      ASPAR=0
      B=0
      DO IE=1,MNE
        DO I1=1,3
          I2=POS_TRICK(I1,1)
          I3=POS_TRICK(I1,2)
          IP1=INE(IE,I1)
          IP2=INE(IE,I2)
          IP3=INE(IE,I3)
          IDX1=JA_IE(I1,1,IE)
          IDX2=JA_IE(I1,2,IE)
          IDX3=JA_IE(I1,3,IE)
          CALL COMPUTE_DIFF(IE, I1, UGRAD1, VGRAD1)
          eFX =( FX(IP1) +  FX(IP2) +  FX(IP3))/3.0_rkind
          eFY =( FY(IP1) +  FY(IP2) +  FY(IP3))/3.0_rkind
          eDep=(DEP(IP1) + DEP(IP2) + DEP(IP3))/3.0_rkind
          eScal=UGRAD1*eFX + VGRAD1*eFY
          B(IP) = B(IP) + eScal
          !
          DO IDX=1,3
            CALL COMPUTE_DIFF(IE, IDX, UGRAD, VGRAD)
            eScal=UGRAD*UGRAD1 + VGRAD*VGRAD1
            ASPAR(IDX)=ASPAR(IDX)+G9*eDep*eScal
          END DO
        END DO
      END DO
      END SUBROUTINE
!**********************************************************************
!*                                                                    *
!**********************************************************************
      SUBROUTINE JCG_SOLVE_POISSON_NEUMANN(TheInp, TheOutPrev, TheOut)
      USE DATAPOOL
! use jacobi preconditioner. Inspired from solve_jcg
      real(rkind), intent(in) :: TheInp(MNP), TheOutPrev(MNP)
      real(rkind), intent(out) :: TheOut(MNP)



      END SUBROUTINE
!**********************************************************************
!*                                                                    *
!**********************************************************************
#ifdef PETSC
      SUBROUTINE PETSC_SOLVE_POISSON_NEUMANN(TheInp, TheOut)
      USE DATAPOOL
      USE ELFE_GLBL, ONLY : iplg, np_global
      USE elfe_msgp, only : myrank, nproc, comm
      use elfe_glbl, only: ipgl1=> ipgl
      ! iplg1 points to elfe_glbl::ipgl because ipgl exist allreay as integer in this function
      use petscpool
      use petscsys
      use petscmat
      implicit none
      real(rkind), intent(in) :: TheInp(MNP)
      real(rkind), intent(out) :: TheOut(MNP)
      integer :: I, J
      integer :: IP, IPGL, IE, POS
      integer :: I1, I2, I3
      integer :: POS_TRICK(3,2)

      real(kind=8)  :: X(MNP)
      real(kind=8)  :: B(MNP)
      real(kind=8)  :: ASPAR(NNZ)

      REAL    ::  TIME2
      ! solver timings
      real    ::  startTime, endTime
      real, save :: solverTimeSum = 0
!
! Petsc stuff
!
      PetscInt :: ncols
      PetscInt :: eCol
      PetscScalar :: eEntry

      integer :: counter

      KSPConvergedReason reason;
      ! solver iteration
      PetscInt iteration
      integer, save  :: iterationSum = 0        

      call PetscLogStagePush(stageFill, petscErr);CHKERRQ(petscErr)
         
      iteration = 0
!
! code for ASPAR and B. Need to write it.
!


! fill the new matrix
      ASPAR_petsc = 0
      oASPAR_petsc = 0
      counter = 1
      ncols = 0
      do i = 1, NP_RES
        ncols = IA(i+1) - IA(i)
        ! this is a interface node (row). ignore it. just increase counter
        if(ALOold2ALO(i-1) .eq. -999) then
          counter = counter + ncols
          cycle
        end if
        ! insert col by col into matrix
        do j = 1, ncols
          if(CSR_App2PetscLUT(counter) == -999) then
            oASPAR_petsc(o_CSR_App2PetscLUT(counter)) =  ASPAR(counter)
          else
            ASPAR_petsc(CSR_App2PetscLUT(counter)) = ASPAR(counter)
          endif
          counter = counter + 1
        end do
      end do
      call MatAssemblyBegin(matrix, MAT_FINAL_ASSEMBLY, petscErr)
      CHKERRQ(petscErr)
      call MatAssemblyEnd(matrix, MAT_FINAL_ASSEMBLY, petscErr)
      CHKERRQ(petscErr)

!fill RHS vector
!iterate over all resident (and interface) nodes
!map it to petsc global ordering
!and insert the value from B into RHS vector
      eEntry = 0;
      call VecSet(myB, eEntry, petscErr);CHKERRQ(petscErr)
      do i= 1, np
        ! this is a interface node (row). ignore it. just increase counter
        if(ALOold2ALO(i-1) .eq. -999) then
          cycle
        end if
        ! map to petsc global order
        eCol = AGO2PGO(iplg(i) - 1 )
        eEntry = B(i)
        call VecSetValue(myB, eCol, eEntry, ADD_VALUES, petscErr)
        CHKERRQ(petscErr)
      end do

      call VecAssemblyBegin(myB, petscErr);CHKERRQ(petscErr);
      call VecAssemblyEnd(myB, petscErr);CHKERRQ(petscErr);

      ! Copy the old solution from AC2 to myX to make the solver faster
      do i = 1, np
        eCol = AGO2PGO(iplg(i)-1)
        eEntry = AC2(i, ISS, IDD)
        call VecSetValue(myX,eCol,eEntry,INSERT_VALUES,petscErr)
        CHKERRQ(petscErr)
      end do
      call VecAssemblyBegin(myX, petscErr);CHKERRQ(petscErr);
      call VecAssemblyEnd(myX, petscErr);CHKERRQ(petscErr);

      ! Solve
      ! To solve successive linear systems that have different preconditioner matrices (i.e., the matrix elements
      ! and/or the matrix data structure change), the user must call KSPSetOperators() and KSPSolve() for each
      ! solve.
      if(samePreconditioner .eqv. .true.) call KSPSetOperators(Solver, matrix, matrix, SAME_PRECONDITIONER, petscErr);CHKERRQ(petscErr)
      call PetscLogStagePop(petscErr);CHKERRQ(petscErr)
      call PetscLogStagePush(stageSolve, petscErr);CHKERRQ(petscErr)
      call CPU_TIME(startTime)
      ! Solve!
      call KSPSolve(Solver, myB, myX, petscErr);CHKERRQ(petscErr);
      call CPU_TIME(endTime)
      call PetscLogStagePop(petscErr);CHKERRQ(petscErr)
         
      call KSPGetConvergedReason(Solver, reason, petscErr);CHKERRQ(petscErr);
      if (reason .LT. 0) then
        !CALL WWM_ABORT('Failure to converge')
        !write(stat%fhndl,*) 'Failure to converge'
      endif

#ifdef PETSC_DEBUG
      if(rank == 0) then
        if(reason .LT. 0 ) then
          write(DBG%FHNDL,*) "Failure to converge\n"
        else
          call KSPGetIterationNumber(Solver, iteration, petscErr)
          CHKERRQ(petscErr)
          ! print only the mean number of iteration
          iterationSum = iterationSum + iteration
          solverTimeSum = solverTimeSum + (endTime - startTime)
          if(ISS == MSC .and. IDD == MDC) then
            write(DBG%FHNDL,*) "mean number of iterations", iterationSum / real((MSC*MDC))
            print '("solver Time for all MSD MDC= ",f6.3," sec")', solverTimeSum
          endif
        endif
      endif
#endif

      X = 0.0_rkind
      !get the solution back to fortran.
      !iterate over all resident nodes (without interface and ghost nodes)
      !map the solution from petsc local ordering back to app old local ordering
      !(the app old ordering contains interface nodes)
      call VecGetArrayF90(myX, myXtemp, petscErr); CHKERRQ(petscErr)
      do i = 1, nNodesWithoutInterfaceGhosts
        X(ipgl1((PGO2AGO(PLO2PGO(i-1)))+1)%id) = myXtemp(i)
      end do
      call VecRestoreArrayF90(myX, myXtemp, petscErr)
      CHKERRQ(petscErr);
      !IF (SUM(X) .NE. SUM(X)) CALL WWM_ABORT('NaN in X')
      ! we have to fill the ghost and interface nodes with the solution from the other threads
      ! at least subroutine SOURCETERMS() make calculations on interface/ghost nodes which are
      ! normally set to 0, because they do net exist in petsc
      !call exchange_p2d(X)
      TheOut = X
      END SUBROUTINE
!**********************************************************************
!*                                                                    *
!**********************************************************************
      SUBROUTINE INIT_WAVE_SETUP
# ifdef MPI_PARALL_GRID
      IF (AMETHOD ne 4) THEN
        CALL PETSC_INIT_PARALLEL
      END IF
# endif
      END SUBROUTINE
!**********************************************************************
!*                                                                    *
!**********************************************************************
      SUBROUTINE FINALIZE_WAVE_SETUP
# ifdef MPI_PARALL_GRID
      IF (AMETHOD ne 4) THEN
        CALL PETSC_FINALIZE_PARALLEL
      END IF
# endif
      END SUBROUTINE
!**********************************************************************
!*                                                                    *
!**********************************************************************
      SUBROUTINE COMPUTE_WAVE_SETUP
      USE DATAPOOL
      implicit none
      REAL(rkind) :: TheDiv(MNP)
      CALL COMPUTE_DIVERGENCE_LH_STRESS(TheDiv)


      END SUBROUTINE
#endif