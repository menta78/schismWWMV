!
!===============================================================================
!===============================================================================
! ELFE transport models using implicit TVD in the vertical, explicit TVD
! in the horizontal.
!
!  subroutine do_transport_tvd_imp
!
!===============================================================================
!===============================================================================
!

!     Do upwind and TVD transport
      subroutine do_transport_tvd_imp(it,imod,up_tvd,tvd_mid,flimiter,ntr,difnum_max_l,nvrt1,npa1,dfh1)

!#ifdef USE_MPIMODULE
!      use mpi
!#endif
      use elfe_glbl
      use elfe_msgp
      use misc_modules

!#ifdef USE_TIMOR
!      USE flmud_pool, only: wsink !wsink(ntracers,nvrt,npa)>=0 (positive down)
!#endif /*USE_TIMOR*/
      implicit none
!#ifndef USE_MPIMODULE
      include 'mpif.h'
!#endif

      integer, intent(in) :: it !time stepping #; info only
      integer, intent(in) :: imod !=0: ST equations; 1: other tracers
      logical, intent(in) :: up_tvd !true if TVD is used (must be for all tracers)
      character(len=2), intent(in) :: tvd_mid,flimiter
      integer, intent(in) :: ntr !# of tracers
      integer, intent(in) :: nvrt1,npa1 !for dimensioning
      real(rkind), intent(in) :: dfh1(nvrt1,npa1) 
      real(rkind), intent(out) :: difnum_max_l !max. horizontal diffusion number reached by this process (check stability)


!     Functions used
#ifdef CHOOSE_TVD
#define flux_lim( a, b ) flux_lim1( ( a ), ( b ) )
       real(rkind) :: flux_lim1
#else
#define flux_lim( a, b )  flux_lim2( ( a ) )
       real(rkind) :: flux_lim2     
#endif

!     Working temporary arrays in this routine
      real(rkind) :: iupwind_e(ne) !to mark upwind prisms when TVD is used
      real(rkind), allocatable :: trel_tmp(:,:,:) !tracer @ elements and half levels
      real(rkind), allocatable :: flux_adv_hface(:,:) ! original horizontal flux (the local x-driection) 
      real(rkind), allocatable :: flux_mod_hface(:,:,:) !limited advective fluxes on horizontal faces
      real(rkind), allocatable :: flux_mod_vface(:,:,:) !limited advective fluxes on vertical faces
      real(rkind), allocatable :: up_rat_hface(:,:,:) !upwind ratios for horizontal faces
!      real(rkind), allocatable :: up_rat_vface(:,:,:) !upwind ratios for vertical faces
      real(rkind) :: buf(2,1),buf2(2,1)
      !-------------------arrays added by Fei-------------------------
      real(rkind), allocatable :: gradU(:,:),deltaUS(:,:),deltaUT(:,:) !temporary array holding spatial/temporal increments of concentration
      real(rkind), allocatable :: omega(:) !implicitness factor, for hybrid scheme
      real(rkind), allocatable :: u_p(:) !used for hybrid scheme
      real(rkind), allocatable :: psi0(:,:) !time limiter from the previous iteration
      real(rkind), allocatable :: psi1(:,:) !time limiter from the current iteration
      real(rkind), allocatable :: phi0(:,:) !spatial limiter from the previous time step (not iteration)
      real(rkind), allocatable :: phi1(:,:) !spatial limiter from the current iteration 
      real(rkind), allocatable :: r_s(:) !local Courant number, this variable is only used in determining psi
      real(rkind), allocatable :: w_r(:) !=omega*r_s, used for hybrid scheme
      real(rkind), allocatable :: faceL(:,:) !TVD modification on approximated concentrations at faces with upward flux
<<<<<<< HEAD
      real(rkind), allocatable :: faceLT(:,:) !TVD modification on approximated concentrations at faces with upward flux
      real(rkind), allocatable :: faceR(:,:) !TVD modification on approximated concentrations at faces with downward flux
      real(rkind), allocatable :: faceRT(:,:) !TVD modification on approximated concentrations at faces with downward flux
=======
      real(rkind), allocatable :: faceR(:,:) !TVD modification on approximated concentrations at faces with downward flux
>>>>>>> 8b58d170a780f99abe62a58205e9ea8e1db083a7
      real(rkind), allocatable :: bigv_m(:,:) !prism volume
      real(rkind), allocatable :: res(:) !residual terms (or right hand side terms)
      real(rkind), allocatable :: v_diff(:,:) !vertical diffusive flux
      integer, allocatable :: iConv(:) !convergence identifier for ntr tracers
      integer, parameter :: itmax=500 !maximum iterations
      real(rkind), parameter :: conv=1e-8 !convergence criteria
      integer :: iterK,iele_max !variables recording the convergence history
!#define RECORD_ITER
!#define Out_Courant
#ifdef Out_Courant
      real(rkind), allocatable :: r_s0(:) !local Courant number
#endif
      !-------------------end arrays added by Fei-------------------------

#ifdef DEBUG
      real(rkind) :: dtbe(ne)
#endif

      real(rkind) :: psumtr(ntr),delta_tr(ntr),adv_tr(ntr), &
     &alow(nvrt),bdia(nvrt),cupp(nvrt),rrhs(ntr,nvrt),soln(ntr,nvrt),gam(nvrt), &
     &swild(max(3,nvrt)),swild4(3,2),trel_tmp_outside(ntr)
      integer :: nwild(2)

      integer :: istat,i,j,k,l,m,khh2,ie,n1,n2,n3,isd,isd0,isd1,isd2,isd3,j0, &
                 &nd,it_sub,ntot_v,ntot_vgb,ntot_h,ntot_hgb,kup,kdo,jsj,kb, &
                 &kb1,iup,ido,ie01,lev01,in_st,jj,ll,lll,ndim,kin,iel,ibnd, &
                 &ndo,ind1,ind2,nd1,nd2,ibio
      real(rkind) :: vnor1,vnor2,xcon,ycon,zcon,dot1,sum1,tmp,cwtmp,toth, &
                     &time_r,psum,rat,dtbl,dtb,vj,av_df,av_dz,hdif_tmp, &
                     &av_h,difnum,cwtmp2,bigv,dt_by_bigv,dtb_by_bigv,term1,term2,term3,term4,temp,term5,term6

      real(rkind) :: ref_flux
      logical     :: same_sign, is_land
!      logical, save :: first_call
      
#ifdef INCLUDE_TIMING
      cwtmp2=mpi_wtime()
#endif

      allocate(trel_tmp(ntr,nvrt,nea), &
<<<<<<< HEAD
              &flux_adv_hface(nvrt,nsa), &
              &flux_mod_hface(ntr,nvrt,ns),flux_mod_vface(ntr,nvrt,ne), &
              &up_rat_hface(ntr,nvrt,nsa), &
              &gradU(ntr,nvrt),deltaUS(ntr,nvrt),deltaUT(ntr,nvrt),omega(nvrt),u_p(nvrt),psi0(ntr,nvrt),psi1(ntr,nvrt), &
              &phi0(ntr,nvrt),phi1(ntr,nvrt),r_s(nvrt),w_r(nvrt), &
              &faceL(ntr,nvrt),faceR(ntr,nvrt),faceLT(ntr,nvrt),faceRT(ntr,nvrt),bigv_m(nea,nvrt),res(nvrt), &
              &v_diff(nvrt,nea),iConv(ntr),stat=istat)
      if(istat/=0) call parallel_abort('Transport: fail to allocate')
#ifdef Out_Courant
      allocate(r_s0(nvrt), stat=istat)
      if(istat/=0) call parallel_abort('Transport: fail to allocate')
=======
               flux_adv_hface(nvrt,nsa), flux_adv_vface(nvrt,nea), &
               flux_mod_hface(ntr,nvrt,ns),flux_mod_vface(ntr,nvrt,ne), &
               up_rat_hface(ntr,nvrt,nsa),up_rat_vface(ntr,nvrt,nea), &
               gradU(ntr,nvrt),deltaUS(ntr,nvrt),deltaUT(ntr,nvrt),omega(nvrt),u_p(nvrt),psi0(ntr,nvrt),psi1(ntr,nvrt), &
               phi0(ntr,nvrt),phi1(ntr,nvrt),r_s(nvrt),w_r(nvrt), &
               faceL(ntr,nvrt),faceR(ntr,nvrt),bigv_m(nea,nvrt),res(nvrt), &
               v_diff(nvrt,nea),iConv(ntr),stat=istat)
      if(istat/=0) call parallel_abort('Transport: fail to allocate')
#ifdef Out_Courant
      allocate(r_s0(nvrt), stat=istat)
      if(istat/=0) call parallel_abort('Transport: fail to allocate')
>>>>>>> 8b58d170a780f99abe62a58205e9ea8e1db083a7
#endif

!    Sanity check for flimiter
#ifndef CHOOSE_TVD
     if (up_tvd.and..not. (flimiter == 'SB' .and. tvd_mid=='AA'))then
         call parallel_abort('Non-default tvd limiter or algorithm choice &
     &not allowed. Either use flimiter=Superbee and tvd_mid=AA or recompile and define CHOOSE_TVD.')
     endif
#endif /* CHOOSE_TVD */

!     For TVD, prepare some arrays for 2-tier ghosts
#ifdef INCLUDE_TIMING
      cwtmp=mpi_wtime()
      timer_ns(1)=timer_ns(1)+cwtmp-cwtmp2
#endif
      if(up_tvd) then
        idry_e_2t(1:ne)=idry_e(1:ne)
        call exchange_e2di_2t(idry_e_2t) !now has values up to nea2
        call exchange_e3d_2t_tr(tr_el)
      endif !up_tvd
#ifdef INCLUDE_TIMING
      wtimer(9,2)=wtimer(9,2)+mpi_wtime()-cwtmp
#endif

!'    Modify here 3D velocity for transport (for whatever reason) - make sure volume conservation is not violated
!     Use we_fv for vertical vel.
!     For rewetted elements, tr_el takes the value from last wet step

!     Compute (pre-limiting) fluxes at all faces 
      flux_adv_hface=-1.d34 !flags
!      flux_adv_vface=-1.d34 !flags

!     Horizontal fluxes
      do j=1,ns !resident side
        if(idry_s(j)==1) cycle
        is_land=(isdel(2,j)==0.and.isbs(j)<=0)

        do k=kbs(j)+1,nvrt
          if(is_land) then !land
            flux_adv_hface(k,j)=0.d0
          else            
            if(ics==1) then
              vnor1=su2(k,j)*sframe(1,1,j)+sv2(k,j)*sframe(2,1,j)
              vnor2=su2(k-1,j)*sframe(1,1,j)+sv2(k-1,j)*sframe(2,1,j)
            else !lat/lon
              vnor1=su2(k,j)
              vnor2=su2(k-1,j)
            endif !ics
            flux_adv_hface(k,j)=(zs(k,j)-zs(k-1,j))*distj(j)*(vnor1+vnor2)/2 !normal * area = flux (in local x-direction)

!           Debug
!           if(it==46.and.i==58422) write(99,*)j,k,vnor1,vnor2,flux_adv_hface(k,jsj)
          endif !is_land
        enddo !k=kbs(i)+1,nvrt
      enddo !j=1,ns

!     Exchange flux_adv
#ifdef INCLUDE_TIMING
      cwtmp=mpi_wtime()
      timer_ns(1)=timer_ns(1)+cwtmp-cwtmp2
#endif
      call exchange_s3dw(flux_adv_hface)
!      call exchange_e3dw(flux_adv_vface)
#ifdef INCLUDE_TIMING
      wtimer(9,2)=wtimer(9,2)+mpi_wtime()-cwtmp
#endif
 
#ifdef INCLUDE_TIMING
      cwtmp2=mpi_wtime()
#endif

!     Mark upwind prisms for efficiency
      if(up_tvd) then
        iupwind_e=0
        do i=1,ne
          if(itvd_e(i)==0) then
            iupwind_e(i)=1 
          else !itvd_e=1
            do j=1,i34(i)
              nd=elnode(j,i)
              toth=eta2(nd)+dp(nd)
              if(toth<h_tvd) then
                iupwind_e(i)=1; exit
              endif
            enddo !j
          endif !itvd_e
        enddo !i=1,ne
      endif !up_tvd

      do i=1,ntr
        flux_mod_hface(i,1:nvrt,1:ns)=flux_adv_hface(1:nvrt,1:ns)
        flux_mod_vface(i,1:nvrt,1:ne)=flux_adv_vface(1:nvrt,1:ne)
      enddo !i

!     Debug
!      do i=1,ne
!        if(idry_e(i)==1) cycle
!        do k=kbe(i)+1,nvrt
!          if(flux_mod_vert(1,k,i)<-1.d33) then
!            write(errmsg,*)'Vertical flux: out of bound',ielg(i),k,flux_mod(1,k,2,i),flux_adv_vface(k,i)
!            call parallel_abort(errmsg)
!          endif
!        enddo !k
!      enddo !i

#ifdef DEBUG
      dtbe=dt !min (over all subcycles and all levels) time step allowed at each element
#endif

      it_sub=0
      time_r=dt !time remaining
      difnum_max_l=0 !max. diffusion number reached by this process (check stability)
      loop11: do
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      it_sub=it_sub+1

!     Compute flux limiters and modify fluxes
      if(up_tvd) then !TVD is used for all tracers
        up_rat_hface=-1.d34 !flags
!        up_rat_vface=-1.d34 !flags

!       Horizontal limiters
#ifdef DEBUG
        ntot_h=0 !total # of horizontal faces that have large limiters (for 1st tracer)
#endif
        do i=1,ns !residents
          if(idry_s(i)==1) cycle

!         At least one element is wet
          up_rat_hface(:,:,i)=-1.d0 !initialize (for below bottom and abnomral cases)
          if(isdel(2,i)==0.or.(isdel(2,i)/=0.and.idry_e(max(1,isdel(2,i)))==1).or.idry_e(isdel(1,i))==1) cycle

!         Not bnd face; 2 elements are wet
!          kb1=min(kbe(isdel(1,i)),kbe(isdel(2,i)))
!          kb=max(kbe(isdel(1,i)),kbe(isdel(2,i)))
!          do k=kb1+1,kb-1
!            if(flux_adv_hface(k,i)/=0) then
!              write(errmsg,*)'Pls zero out the excess layers:',flux_adv_hface(k,i),i,isdel(1,i),isdel(2,i),k,kb1,kb
!              call parallel_abort(errmsg)
!            endif
!          enddo !k
 
!         Leave k=kbs unchanged
          do k=kbs(i)+1,nvrt !faces
            if(flux_adv_hface(k,i)<-1.d33) then
              write(errmsg,*)'Left out horizontal flux (3):',i,k
              call parallel_abort(errmsg)
            endif
            if(flux_adv_hface(k,i)>0) then
              iup=isdel(1,i); ido=isdel(2,i) !up/downwind prisms
            else
              iup=isdel(2,i); ido=isdel(1,i)
            endif

            psum=0 !!sum of original fluxes
            psumtr(1:ntr)=0 !sum of products (|Q|*(T-T))
!            if(flux_adv_vface(k,iup)<-1.d33.or.flux_adv_vface(k-1,iup)<-1.d33) then
!              print*,flux_adv_vface(k,iup), flux_adv_vface(k-1,iup)
!              write(errmsg,*)'Left out vertical flux (6):',iup,k
!              call parallel_abort(errmsg)
!            endif
!            if(flux_adv_vface(k,iup)<0.and.k/=nvrt) then
!              psum=psum+abs(flux_adv_vface(k,iup))
!              psumtr(1:ntr)=psumtr(1:ntr)+abs(flux_adv_vface(k,iup))*(tr_el(1:ntr,k+1,iup)-tr_el(1:ntr,k,iup))
!            endif
!            if(flux_adv_vface(k-1,iup)>0.and.k>kbe(iup)+1) then
!              psum=psum+abs(flux_adv_vface(k-1,iup))
!              psumtr(1:ntr)=psumtr(1:ntr)+abs(flux_adv_vface(k-1,iup))*(tr_el(1:ntr,k-1,iup)-tr_el(1:ntr,k,iup))
!            endif
            do j=1,i34(iup)
              jsj=elside(j,iup)
              ie=ic3(j,iup) !must be inside aug. domain; >=0
#ifdef DEBUG
              if(ie>0) then !inside 1-tier aug. domain
                !Check consistency between iegl and iegl2 etc
                if(ielg(ie)/=ielg2(ie)) call parallel_abort('TRANS:2.1')
                ind1=ielg(ie)
                if(iegl2(1,ind1)/=myrank) call parallel_abort('TRANS:2.3')
                if(iegl(ind1)%id/=iegl2(2,ind1)) call parallel_abort('TRANS:2.2')
                if(idry_e_2t(ie)/=idry_e(ie)) call parallel_abort('TRANS:2.4')
!'
              endif
#endif
              if(ie<0) then !outside 1-tier aug. domain
                ie=iabs(ie) !global elem.
!Error: eventually into DEBUG or assert mode
                if(iegl2(1,ie)/=myrank) then
                  write(errmsg,*)'TVD: element outside:',ie
                  call parallel_abort(errmsg)
                endif
                ind1=iegl2(2,ie) !local elem. index in 2-tier aug. domain
                if(ind1<=nea.or.ind1>nea2) then
                  write(errmsg,*)'TVD: element wrong:',ind1,nea,nea2
                  call parallel_abort(errmsg)
                endif
                ie=ind1
              endif

              !idry_e_2t, tr_el are valid up to 2-tier aug.
              if(ie/=0) then; if(idry_e(ie)==0.and.k>=kbs(jsj)+1.and.ssign(j,iup)*flux_adv_hface(k,jsj)<0) then
#ifdef DEBUG
                if(flux_adv_hface(k,jsj)<-1.d33) then
                  write(errmsg,*)'Left out horizontal flux (6):',jsj,k
                  call parallel_abort(errmsg)
                endif
#endif
                psum=psum+abs(flux_adv_hface(k,jsj))
                psumtr(1:ntr)=psumtr(1:ntr)+abs(flux_adv_hface(k,jsj))*(tr_el(1:ntr,k,ie)-tr_el(1:ntr,k,iup))
              endif; endif
            enddo !j
#ifdef CHOOSE_TVD     
            if(tvd_mid.eq.'AA') then
#endif
              do j=1,ntr
                tmp=(tr_el(j,k,iup)-tr_el(j,k,ido))*abs(flux_adv_hface(k,i))
                if(abs(tmp)>1.e-20) up_rat_hface(j,k,i)=psumtr(j)/tmp
              enddo !j
#ifdef CHOOSE_TVD
            else !model CC
              do j=1,ntr
                tmp=(tr_el(j,k,iup)-tr_el(j,k,ido))*psum
                if(abs(tmp)>1.e-20) up_rat_hface(j,k,i)=psumtr(j)/tmp
              enddo !j
            endif
#endif
#ifdef DEBUG
            if(flux_lim( up_rat_hface(1,k,i), flimiter ) &
     &>0.1) ntot_h=ntot_h+1
#endif
          enddo !k=kbs(i)+1,nvrt
        enddo !i=1,ns

!       Debug
!        if(it==1.and.it_sub==1) then
!          do i=1,ne
!            do j=1,3
!              jsj=elside(j,i)
!              write(99,*)isdel(1,jsj),isdel(2,jsj),up_rat()
!            enddo !j
!          enddo !i
!          stop
!        endif

!       Reset upwind ratios and flux_mod for upwind prism faces
        do i=1,ne
          if(iupwind_e(i)/=0) then
            !up_rat_vface(:,:,i)=0
            do j=1,i34(i) !sides
              up_rat_hface(:,:,elside(j,i))=0
            enddo !j
          endif
        enddo !i=1,ne

#ifdef INCLUDE_TIMING
        timer_ns(1)=timer_ns(1)+mpi_wtime()-cwtmp2
#endif

!       Exchange up_rat
        if(ntr==2) then
#ifdef INCLUDE_TIMING
          cwtmp=mpi_wtime()
#endif
          call exchange_s3d_2(up_rat_hface)
!          call exchange_e3d_2(up_rat_vface)
#ifdef INCLUDE_TIMING
          wtimer(9,2)=wtimer(9,2)+mpi_wtime()-cwtmp
#endif
        else if(ntr==ntracers) then
#ifdef INCLUDE_TIMING
          cwtmp=mpi_wtime()
#endif
          call exchange_s3d_tr2(up_rat_hface)
!          call exchange_e3d_tr2(up_rat_vface)
#ifdef INCLUDE_TIMING
          wtimer(9,2)=wtimer(9,2)+mpi_wtime()-cwtmp
#endif
        else
          call parallel_abort('Transport: unknown tracer number')
        endif

#ifdef INCLUDE_TIMING
        cwtmp2=mpi_wtime()
#endif

!       Modified horizontal fluxes
        do i=1,ns
          if(idry_s(i)==1.or.isdel(2,i)==0.or.idry_e(isdel(1,i))==1) cycle
          if(idry_e(isdel(2,i))==1) cycle

!         Both elements are wet
!          kb=max(kbe(isdel(1,i)),kbe(isdel(2,i)))
          do k=kbs(i)+1,nvrt
            if(flux_adv_hface(k,i)>0) then
              iup=isdel(1,i)
            else
              iup=isdel(2,i)
            endif
 
            delta_tr(1:ntr)=0
!            do l=0,1 !two vertical faces of upwind prism
!              if(flux_adv_vface(k-l,iup)*(1-2*l)>0) then !outflow
!                do j=1,ntr
!                  rat=up_rat_vface(j,k-l,iup)
!      !@            if(rat<-1.d33) then
!      !@              write(errmsg,*)'Left out (5):',iup,k-l,rat,j
!      !@              call parallel_abort(errmsg)
!      !@             endif
!                  if(abs(rat)>1.d-5) then
!                    tmp=flux_lim(rat,flimiter)/rat/2.d0
!      !@              if(tmp<0.or.tmp>1) then
!      !@                write(errmsg,*)'Flux limiting failed (5):',tmp,rat,j
!      !@                call parallel_abort(errmsg)
!      !@             endif
!                    delta_tr(j)=delta_tr(j)+tmp
!                  endif
!                enddo !j=1,ntr
!              endif !outflow face
!            enddo !l=0,1

            do j=1,i34(iup)
              jsj=elside(j,iup) !inside aug. domain
!              ie=ic3(j,iup) !not really used
              if(k>=kbs(jsj)+1.and.ssign(j,iup)*flux_adv_hface(k,jsj)>0) then !outflow
                do jj=1,ntr
                  rat=up_rat_hface(jj,k,jsj)
#ifdef DEBUG
                  if(rat<-1.d33) then
                    write(errmsg,*)'Left out (7):',iup,ielg(ie),k,rat,jj
                    call parallel_abort(errmsg)
                  endif
#endif
                  if(abs(rat)>1.e-5) then
                    tmp=flux_lim(rat,flimiter)/rat/2.d0
#ifdef DEBUG
                    if(tmp<0.or.tmp>1) then
                      write(errmsg,*)'Flux limiting failed (7):',tmp,rat,jj
                      call parallel_abort(errmsg)
                    endif
#endif
                    delta_tr(jj)=delta_tr(jj)+tmp
                  endif
                enddo !jj=1,ntr
              endif !outflow
            enddo !j

            do j=1,ntr
              flux_mod_hface(j,k,i)=flux_adv_hface(k,i)*(1.d0 &
     &           - flux_lim( up_rat_hface(j,k,i) , flimiter )/2.d0 &
     &           + delta_tr(j)) 
            enddo !j
          enddo !k=kbs(i)+1,nvrt
        enddo !i=1,ns

      endif !up_tvd; flux limiter

!     Compute sub time step
!     Strike out \hat{S}^- (including all horizontal and vertical bnds, and where ic3(j,i) is dry)
!     Caution: \hat{S}^- conditions must be consistent later in the advective flux part!!!!!!
!     Implicit vertical flux for upwind; explicit for TVD

      if(up_tvd.or.it_sub==1) then !for upwind, only compute dtb for the first step
        dtbl=time_r
        ie01=0 !element # where the exteme is attained (local)
        lev01=0 !level #
        in_st=0 !tracer #
        do i=1,ne
          if(idry_e(i)==1) cycle

          do k=kbe(i)+1,nvrt !prism
            psumtr(1:ntr)=0.d0 !sum of modified fluxes for all inflow bnds
   
!            if(up_tvd.and.iupwind_e(i)==0) then !TVD for all tracers
!              if(k/=nvrt.and.flux_mod_vface(1,k,i)<0) then !flux_mod and flux_adv same sign
!                psumtr(1:ntr)=psumtr(1:ntr)+abs(flux_mod_vface(1:ntr,k,i))
!!               Debug
!!                  if(it==46.and.it_sub==1.and.i==58422) write(99,*)k,flux_adv_vface(k,i)
!              endif
!              if(k-1/=kbe(i).and.flux_mod_vface(1,k-1,i)>0) then
!                psumtr(1:ntr)=psumtr(1:ntr)+abs(flux_mod_vface(1:ntr,k-1,i))
!!               Debug
!!                  if(it==46.and.it_sub==1.and.i==58422) write(99,*)k,flux_adv_vface(k-1,i)
!              endif
!            endif !TVD

            do j=1,i34(i)
              jsj=elside(j,i) !resident side
              ie=ic3(j,i)

              if(k>=kbs(jsj)+1) then
                ref_flux = flux_mod_hface(1,k,jsj)
                same_sign = (ssign(j,i)*ref_flux)<0
!DIR$ IVDEP 
                if((ie/=0.and.idry_e(max(1,ie))==0.or.ie==0.and.isbs(jsj)>0).and.same_sign) then !flux_mod(:) same sign as flux_adv
                  do jj=1,ntr
#ifdef DEBUG
                    if(flux_mod_hface(jj,k,jsj)<-1.d33) then
                      write(errmsg,*)'Left out horizontal flux (10):',i,k,j,jj
                      call parallel_abort(errmsg)
                    endif
#endif

                    psumtr(jj)=psumtr(jj)+abs(flux_mod_hface(jj,k,jsj))
                  enddo !jj
!                     Debug
!                     if(it==46.and.it_sub==1.and.i==58422) write(99,*)j,k,flux_adv_hface(k,jsj)
!                   if(jj==1.and.ssign(j,i)*flux_adv_hface(k,jsj)>0) nplus=nplus+1
                endif !ie
              endif !k>=kbs
            enddo !j

            vj=area(i)*(ze(k,i)-ze(k-1,i))

!               Debug
!                if(it==46.and.it_sub==1.and.i==58422) write(99,*)k,nplus,vj

            do jj=1,ntr
              if(psumtr(jj)/=0) then
                tmp=vj/psumtr(jj)*(1-1.e-6) !safety factor included
                if(tmp<dtbl) then
                  dtbl=tmp 
                  ie01=i; lev01=k; in_st=jj
                endif
#ifdef DEBUG
                if(tmp<dtbe(i)) dtbe(i)=tmp
#endif
              endif
            enddo !jj

!            if(qj/=0) dtb_altl=min(dtb_altl,vj/(1+nplus)/qj*(1-1.e-10)) !safety factor included
          enddo !k=kbe(i)+1,nvrt
        enddo !i=1,ne

#ifdef INCLUDE_TIMING
        cwtmp=mpi_wtime()
        timer_ns(1)=timer_ns(1)+cwtmp-cwtmp2
#endif
        buf(1,1)=dtbl; buf(2,1)=myrank
        call mpi_allreduce(buf,buf2,1,MPI_2DOUBLE_PRECISION,MPI_MINLOC,comm,ierr)
        dtb=buf2(1,1)
#ifdef INCLUDE_TIMING
        cwtmp2=mpi_wtime()
        wtimer(9,2)=wtimer(9,2)+cwtmp2-cwtmp
#endif

#ifdef DEBUG
        if(dtb<=0.or.dtb>time_r) then
          write(errmsg,*)'Transport: Illegal sub step:',dtb,time_r
          call parallel_abort(errmsg)
        endif
#endif

!       Output time step
        if(myrank==int(buf2(2,1)).and.ie01>0) &
     &write(12,'(a20,5(1x,i10),1x,f14.3,1x,e22.10)') &
     &'TVD-upwind dtb info:',it,it_sub,ielg(ie01),lev01,in_st,dtb,it*dt !,dtb_alt 

      endif !up_tvd.or.it_sub==1; compute dtb

      dtb=min(dtb,time_r) !for upwind
      time_r=time_r-dtb

!     Store last step's S,T
      trel_tmp(1:ntr,:,:)=tr_el(1:ntr,:,:)

      do i=1,ne
        if(idry_e(i)==1) cycle

!       Wet elements with 3 wet nodes
        do k=kbe(i)+1,nvrt
          bigv_m(i,k)=area(i)*(ze(k,i)-ze(k-1,i)) !volume
          dtb_by_bigv = dtb/bigv_m(i,k)

!         Advective flux
!         Strike out \hat{S}^- (see above)
          psumtr(1:ntr)=0 !sum of modified fluxes at all inflow bnds 
!         Alternative mass conservative form for the advection part (Eq. C32); contribute to rrhs
          adv_tr(1:ntr)=trel_tmp(1:ntr,k,i) 
!@         if(ntr>1) then; if(flux_mod_vface(1,k,i)*flux_mod_vface(2,k,i)<0) then
!@           write(errmsg,*)'Left out vertical flux (0):',i,k,flux_mod_vface(1:2,k,i)
!@           call parallel_abort(errmsg)
!@         endif; endif
!@          do jj=1,ntr
!@           if(flux_mod_vface(jj,k,i)<-1.d33) then
!@             write(errmsg,*)'Left out vertical flux:',i,k,flux_mod_vface(jj,k,i),jj
!@             call parallel_abort(errmsg)
!@           endif
!@          enddo !jj

!          if(k/=nvrt.and.flux_mod_vface(1,k,i)<0) then !all flux_mod(:) same sign
!            if(up_tvd.and.iupwind_e(i)==0) then !TVD for all tracers
!              do jj=1,ntr
!                psumtr(jj)=psumtr(jj)+abs(flux_mod_vface(jj,k,i))
!                !delta_tr(jj)=delta_tr(jj)+abs(flux_mod_vface(jj,k,i))*trel_tmp(jj,k+1,i)
!                adv_tr(jj)=adv_tr(jj)+dtb_by_bigv*abs(flux_adv_vface(k,i))*(trel_tmp(jj,k+1,i)-trel_tmp(jj,k,i))
!              enddo !jj
!            else !upwind
!              tmp=abs(flux_mod_vface(1,k,i))*dtb_by_bigv !flux_mod(:) all same for upwind
!              cupp(kin)=cupp(kin)-tmp
!              bdia(kin)=bdia(kin)+tmp
!            endif
!          endif
!          if(k-1/=kbe(i).and.flux_mod_vface(1,k-1,i)>0) then
!            if(up_tvd.and.iupwind_e(i)==0) then !TVD for all tracers
!              do jj=1,ntr
!                psumtr(jj)=psumtr(jj)+abs(flux_mod_vface(jj,k-1,i))
!                !delta_tr(jj)=delta_tr(jj)+abs(flux_mod_vface(jj,k-1,i))*trel_tmp(jj,k-1,i)
!                adv_tr(jj)=adv_tr(jj)+dtb_by_bigv*abs(flux_adv_vface(k-1,i))*(trel_tmp(jj,k-1,i)-trel_tmp(jj,k,i))
!              enddo !jj
!            else !upwind
!              tmp=abs(flux_mod_vface(1,k-1,i))*dtb_by_bigv
!              alow(kin)=alow(kin)-tmp
!              bdia(kin)=bdia(kin)+tmp
!            endif
!          endif

!         Additional terms in adv_tr (Eq. C32)
!          if(up_tvd) then
!            if(k/=nvrt) then
!              do jj=1,ntr
!                adv_tr(jj)=adv_tr(jj)+dtb_by_bigv*abs(flux_adv_vface(k,i))*(trel_tmp(jj,k,i)&
!     &              - trel_tmp(jj,k+1,i))* &
!     &              flux_lim( up_rat_vface(jj,k,i), flimiter )/2.d0
!              enddo !jj
!            endif
!            if(k-1/=kbe(i)) then
!              do jj=1,ntr
!                adv_tr(jj)=adv_tr(jj)+dtb_by_bigv*abs(flux_adv_vface(k-1,i))*(trel_tmp(jj,k,i) &
!     &                     - trel_tmp(jj,k-1,i))* &
!     &             flux_lim( up_rat_vface(jj,k-1,i), flimiter )/2.d0
!              enddo !jj
!            endif
!          endif !TVD

!         Horizontal faces
          do j=1,i34(i)
            jsj=elside(j,i) !resident side
            iel=ic3(j,i)

            if(iel/=0) then
              if(idry_e(iel)==1) cycle
              trel_tmp_outside(:)=trel_tmp(:,k,iel)
            else !bnd side
              if(isbs(jsj)<=0.or.k>=kbs(jsj)+1.and.ssign(j,i)*flux_mod_hface(1,k,jsj)>=0) cycle
       
              !Open bnd side with _inflow_; compute trel_tmp from outside and save it as trel_tmp_outside(1:ntr)
              ibnd=isbs(jsj) !global bnd #
              !Find node indices on bnd segment for the 2 nodes (for type 4 b.c.)
              nwild(1:2)=0
              do ll=1,2 !nodes
                ndo=isidenode(ll,jsj)
                do lll=1,2 !2 possible bnds
                  if(isbnd(lll,ndo)==ibnd) then
                    nwild(ll)=isbnd(-lll,ndo) !global index
                    exit
                  endif
                enddo !lll
              enddo !ll
              ind1=nwild(1); ind2=nwild(2);
     !@         if(ind1==0.or.ind2==0) then
     !@           write(errmsg,*)'Cannot find a local index'
     !@           call parallel_abort(errmsg)
     !@        endif

              if(imod==0) then !TS
                if(itetype(ibnd)==0) then !set to be same as interior (so cancel out below)
                  trel_tmp_outside(1)=trel_tmp(1,k,i)
                else if(itetype(ibnd)==1.or.itetype(ibnd)==2) then
                  trel_tmp_outside(1)=tobc(ibnd)*tth(1,1,ibnd)+(1-tobc(ibnd))*trel_tmp(1,k,i)
                else if(itetype(ibnd)==3) then
                  tmp=(tem0(k,isidenode(1,jsj))+tem0(k-1,isidenode(2,jsj)))/2.d0
                  trel_tmp_outside(1)=tobc(ibnd)*tmp+(1-tobc(ibnd))*trel_tmp(1,k,i)
                else if(itetype(ibnd)==4) then
                  tmp=(tth(k,ind1,ibnd)+tth(k-1,ind1,ibnd)+tth(k,ind2,ibnd)+tth(k-1,ind2,ibnd))/4
                  trel_tmp_outside(1)=tobc(ibnd)*tmp+(1-tobc(ibnd))*trel_tmp(1,k,i)
                else
                  write(errmsg,*)'TRASNPORT: INVALID VALUE FOR ITETYPE'
                  call parallel_abort(errmsg)
                endif !itetype

                if(isatype(ibnd)==0) then !set to be same as interior (so cancel out below)
                  trel_tmp_outside(2)=trel_tmp(2,k,i)
                else if(isatype(ibnd)==1.or.isatype(ibnd)==2) then
                  trel_tmp_outside(2)=sobc(ibnd)*sth(1,1,ibnd)+(1-sobc(ibnd))*trel_tmp(2,k,i)
                else if(isatype(ibnd)==3) then
                  tmp=(sal0(k,isidenode(1,jsj))+sal0(k-1,isidenode(2,jsj)))/2.d0
                  trel_tmp_outside(2)=sobc(ibnd)*tmp+(1-sobc(ibnd))*trel_tmp(2,k,i)
                else if(isatype(ibnd)==4) then
                  tmp=(sth(k,ind1,ibnd)+sth(k-1,ind1,ibnd)+sth(k,ind2,ibnd)+sth(k-1,ind2,ibnd))/4
                  trel_tmp_outside(2)=sobc(ibnd)*tmp+(1-sobc(ibnd))*trel_tmp(2,k,i)
                else
                  write(errmsg,*)'TRASNPORT: INVALID VALUE FOR ISATYPE'
                  call parallel_abort(errmsg)
                endif !isatype

              else !tracers
                if(itrtype(ibnd)==0) then !set to be same as interior (so cancel out below)
                  trel_tmp_outside(:)=trel_tmp(:,k,i)
                else if(itrtype(ibnd)==1.or.itrtype(ibnd)==2) then
                  trel_tmp_outside(:)=trobc(ibnd)*trth(:,1,1,ibnd)+(1-trobc(ibnd))*trel_tmp(:,k,i)
                else if(itrtype(ibnd)==3) then
                  trel_tmp_outside(:)=trobc(ibnd)*trel0(:,k,i)+(1-trobc(ibnd))*trel_tmp(:,k,i)
                else if(itrtype(ibnd)==4) then
                  trel_tmp_outside(:)=trobc(ibnd)* &
     &(trth(:,k,ind1,ibnd)+trth(:,k,ind2,ibnd)+trth(:,k-1,ind1,ibnd)+trth(:,k-1,ind2,ibnd))/4+ &
     &(1-trobc(ibnd))*trel_tmp(:,k,i)
                else
                  write(errmsg,*)'TRASNPORT: INVALID VALUE FOR ITRTYPE'
                  call parallel_abort(errmsg)
                endif !itrtype
              endif !imod
            endif !iel

!@         if(ntr>1) then; if(flux_mod_hface(1,k,jsj)*flux_mod_hface(2,k,jsj)<0) then
!@           write(errmsg,*)'Left out horizontal flux (0):',i,j,k,flux_mod_hface(1:2,k,jsj)
!@           call parallel_abort(errmsg)
!@         endif; endif
!@         do jj=1,ntr
!@           if(flux_mod_hface(jj,k,jsj)<-1.d33) then
!@             write(errmsg,*)'Left out horizontal flux:',i,j,k,flux_mod_hface(jj,k,jsj),jj
!@             call parallel_abort(errmsg)
!@           endif
!@         enddo !jj

            if(k>=kbs(jsj)+1.and.ssign(j,i)*flux_mod_hface(1,k,jsj)<0) then !inflow
              do jj=1,ntr
#ifdef DEBUG
                if(flux_mod_hface(jj,k,jsj)<-1.d33) then
                  write(errmsg,*)'Left out horizontal flux:',i,j,k,flux_mod_hface(jj,k,jsj),jj
                  call parallel_abort(errmsg)
                endif
#endif
                psumtr(jj)=psumtr(jj)+abs(flux_mod_hface(jj,k,jsj))
                adv_tr(jj)=adv_tr(jj)+dtb_by_bigv*abs(flux_adv_hface(k,jsj))*(trel_tmp_outside(jj)-trel_tmp(jj,k,i))
              enddo !jj
            endif !inflow

            if(up_tvd.and.k>=kbs(jsj)+1) then
              do jj=1,ntr
                adv_tr(jj)=adv_tr(jj)+dtb_by_bigv*abs(flux_adv_hface(k,jsj))*(trel_tmp(jj,k,i)-trel_tmp_outside(jj))* &
     &flux_lim( up_rat_hface(jj,k,jsj), flimiter )/2.d0
              enddo !jj
            endif
          enddo !j

!         Check Courant number
          do jj=1,ntr
            if(1-dtb_by_bigv*psumtr(jj)<0) then
              write(errmsg,*)'Courant # condition violated:',i,k,1-dtb_by_bigv*psumtr(jj),jj
              call parallel_abort(errmsg)
           endif
          enddo !jj

!          rrhs(1:ntr,kin)=adv_tr(1:ntr)
          tr_el(1:ntr,k,i)=adv_tr(1:ntr)

!         Check consistency between 2 formulations in TVD
!            if(up_tvd) then 
!              if(abs(adv_t-rrhs(1,kin))>1.e-4.or.abs(adv_s-rrhs(2,kin))>1.e-4) then
!                write(11,*)'Inconsistency between 2 TVD schemes:',i,k,adv_t,rrhs(1,kin),adv_s,rrhs(2,kin)
!                stop
!              endif
!            endif !TVD

        enddo !k=kbe(i)+1,nvrt

!       Extend
        do k=1,kbe(i)
          tr_el(1:ntr,k,i)=tr_el(1:ntr,kbe(i)+1,i)
        enddo !k
      enddo !i=1,ne

!     Update ghosts
#ifdef INCLUDE_TIMING
      cwtmp=mpi_wtime()
      timer_ns(1)=timer_ns(1)+cwtmp-cwtmp2
#endif
      call exchange_e3d_tr(tr_el)
#ifdef INCLUDE_TIMING
      cwtmp2=mpi_wtime()
      wtimer(9,2)=wtimer(9,2)+cwtmp2-cwtmp
#endif      

      if(time_r<1.e-8) exit loop11
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       end do loop11

      if(myrank==0) write(17,*)it,it_sub
      
!     Debug output of time steps allowed at each element
#ifdef DEBUG
      call elfe_output_custom(istat,5,1,205,'dtbe',1,ne,dtbe)
      if(myrank==0.and.istat==1) write(16,*)'done outputting dtbe.66'
#endif

!     Output tr_el before implicit vertical solver next
      call elfe_output_custom(istat,9,1,221,'trel',nvrt,nea,tr_el(1,:,:))

!     Save the final array from horizontal part as trel_tmp    
      trel_tmp(1:ntr,:,:)=tr_el(1:ntr,:,:)

<<<<<<< HEAD
!...  Fei: below is an e.g. of implicit upwind -feel free to add arrays if needed

#ifdef Out_Courant
      !Debug: file recording the vertical courant number at each element
      open(66,file='courant',status='replace')
#endif

      do i=1,ne
        if(idry_e(i)==1) cycle

!       Wet elements with 3 wet nodes
        n1=elnode(1,i)
        n2=elnode(2,i)
        n3=elnode(3,i)

        iConv=-1 !all tracers set to -1 (not converged) initially

        !temporal limiter set to 0 before the first iteration, which will be updated after each iteration
        psi0=0

        !--------------------Parameters that do not change through iterations------------------
        !spatial limiter from the previous time step, not updated through iterations
        do k=kbe(i)+1,nvrt-1 
            !spatial gradient = dT/dV, note that dV is not the volume of the prism,
            !but between prism centers where T is defined
            deltaUS(1:ntr,k)=trel_tmp(1:ntr,k+1,i)-trel_tmp(1:ntr,k,i)
            gradU(1:ntr,k)=deltaUS(1:ntr,k)/(ze(k+1,i)-ze(k-1,i))*2.0/area(i)
        enddo
        do k=kbe(i)+2,nvrt-1
            do m=1,ntr
                !The selection of TVD spatial limiters will be given a parameter in the future
                !---------Van Leer-----------
                !term1=gradU(m,k)*gradU(m,k-1)
                !term2=gradU(m,k)+gradU(m,k-1)
                !phi0(m,k)=(1.0_rkind+sign(1.0_rkind,term1))*term1/ &
                !    sign(max(abs(term2),epsilon(term2)),term2)

                !---------Minmod-----------
                if  (flux_adv_vface(k,i)*flux_adv_vface(k-1,i)<0 ) then
                    phi0(m,k)=0.0
                elseif (flux_adv_vface(k,i)>0) then  !upward
                    term1=gradU(m,k)*flux_adv_vface(k,i)*bigv_m(i,k)
                    term2=gradU(m,k-1)*flux_adv_vface(k-1,i)*bigv_m(i,k-1)
                    phi0(m,k)= 0.5*(sign(1.0_rkind,term1)+sign(1.0_rkind,term2))  * min(abs(term1),abs(term2))
                else !downward
                    term1=gradU(m,k)*flux_adv_vface(k,i)*bigv_m(i,k+1)
                    term2=gradU(m,k-1)*flux_adv_vface(k-1,i)*bigv_m(i,k)
                    phi0(m,k)= 0.5*(sign(1.0_rkind,term1)+sign(1.0_rkind,term2))  * min(abs(term1),abs(term2))
                endif
!                phi0(m,k)= 0.5*(sign(1.0_rkind,gradU(m,k))+sign(1.0_rkind,gradU(m,k-1))) &
!                    * min(abs(gradU(m,k)),abs(gradU(m,k-1)))

                !---------Superbee-----------
                !term1=gradU(m,k)*gradU(m,k-1)
                !term2=gradU(m,k)/sign(max(abs(gradU(m,k-1)),epsilon(gradU(m,k-1))),gradU(m,k-1))
                !phi0(m,k)=0.5*(1.0+sign(1.0,term1))*gradU(m,k-1)*max(min(2.0*term2,1.0),min(term2,1.0))
            enddo
        enddo
        !Caution: phi=0 at surface (nvrt) and bottom (kbe(i)+1), as well as extended levels
        phi0(1:ntr,1:kbe(i)+1)=0.0_rkind
        phi0(1:ntr,nvrt)=0.0_rkind

!       Vertical diffusive flux
        v_diff(kbe(i),i)=0.0 !bottom
        v_diff(nvrt,i)=0.0 !surface
        do k=kbe(i)+1,nvrt-1
          av_df=(dfh1(k,n1)+dfh1(k,n2)+dfh1(k,n3))/3 !diffusivity
          av_dz=(ze(k+1,i)-ze(k-1,i))/2.d0
          v_diff(k,i)=area(i)*av_df/av_dz
        enddo
          
        !debug: set vertical diffusion to 0 temporarily
        !v_diff=0.0

        !r_s (local Courant number), only used for determining temporal limiter psi
        do k=kbe(i)+1,nvrt
            !r_s(k)=dt/bigv_m(i,k)*sign(max(abs(flux_adv_vface(k,i)),abs(flux_adv_vface(k-1,i))), & 
            !    flux_adv_vface(k,i)+flux_adv_vface(k-1,i) )
            r_s(k)=dt/bigv_m(i,k)*max(abs(flux_adv_vface(k,i)),abs(flux_adv_vface(k-1,i)))+epsilon(1.0)
        enddo
#ifdef Out_Courant
        r_s0(kbe(i)+1:nvrt)=abs(r_s(kbe(i)+1:nvrt))
        r_s0(kbe(i))=maxval(r_s0(kbe(i)+1:nvrt))
        write(66,"(27F19.7)") (xnd(n1)+xnd(n2)+xnd(n3))/3.0, (ynd(n1)+ynd(n2)+ynd(n3))/3.0, r_s0
#endif

        !Matrix, including advective flux and diffusive flux
        ndim=nvrt-kbe(i) !# of eqs/unknowns
        alow=0; bdia=1; cupp=0
        do k=kbe(i)+1,nvrt
          kin=k-kbe(i) 
          dt_by_bigv = dt/bigv_m(i,k)
          if(k<nvrt) then
            tmp=dt_by_bigv*v_diff(k,i)
            cupp(kin)=cupp(kin)-tmp
            bdia(kin)=bdia(kin)+tmp

            !Upwind advection
            tmp=abs(flux_adv_vface(k,i))*dt_by_bigv 
            if(flux_adv_vface(k,i)<0) then !downward inflow
              cupp(kin)=cupp(kin)-tmp
              bdia(kin)=bdia(kin)+tmp
            endif 
          endif !k<nvrt

          if(k>kbe(i)+1) then
            tmp=dt_by_bigv*v_diff(k-1,i)
            alow(kin)=alow(kin)-tmp
            bdia(kin)=bdia(kin)+tmp

            tmp=abs(flux_adv_vface(k-1,i))*dt_by_bigv
            if(flux_adv_vface(k-1,i)>0) then !upward inflow
              alow(kin)=alow(kin)-tmp
              bdia(kin)=bdia(kin)+tmp
            endif
          endif !k>kbe(i)+1

        enddo
        !--------------------End: parameters that do not change through iterations------------------

!--------------------------------------------------------------------------------------------------------
        do iterK=1,itmax !cycle through iterations
        do m=1,ntr !cycle through tracers.
        !Tracer loop is placed inside iteration loop to apply tridag efficiently,
        !although not all tracers converge at the same time, iConv is used to
        !monitor convergence of each tracer
!-----------------------------start iterations-----------------------------------------------------------

        if (iConv(m)==0) cycle !already converged

        if (iterK==1) then !first iteration, use initial phi and psi
            phi1(m,:)=phi0(m,:) !spatial limiter
            psi1(m,:)=psi0(m,:) !temporal limiter
        else
            !this iteration's psi0 is last iteration's psi1
            psi0(m,:)=psi1(m,:)  
            !update temporal limiter
            deltaUT=tr_el(1:ntr,:,i)-trel_tmp(1:ntr,:,i) !temporal increment
            do k=kbe(i)+1,nvrt-1
                term1=max(abs(flux_adv_vface(k,i)),abs(flux_adv_vface(k-1,i)))
                if (deltaUT(m,k)>=0) then
                    psi1(m,k)=max(0.0_rkind,min(2.0_rkind*deltaUT(m,k)/dt*bigv_m(i,k) + psi0(m,k-1), 2.0_rkind*deltaUT(m,k)/dt*bigv_m(i,k) + psi0(m,k+1), deltaUT(m,k)*term1))
                else
                    psi1(m,k)=min(0.0_rkind,max(2.0_rkind*deltaUT(m,k)/dt*bigv_m(i,k) + psi0(m,k-1), 2.0_rkind/dt*bigv_m(i,k)*deltaUT(m,k) + psi0(m,k+1), deltaUT(m,k)*term1))
                endif
            enddo
            term1=max(abs(flux_adv_vface(nvrt,i)),abs(flux_adv_vface(nvrt-1,i)))
            if (deltaUT(m,nvrt)>=0) then
                psi1(m,nvrt)=max(0.0_rkind,min(2.0_rkind/dt*bigv_m(i,nvrt)*deltaUT(m,nvrt) + psi0(m,nvrt-1), 2.0_rkind/dt*bigv_m(i,nvrt)*deltaUT(m,nvrt), deltaUT(m,nvrt)*term1))
            else
                psi1(m,nvrt)=min(0.0_rkind,max(2.0_rkind/dt*bigv_m(i,nvrt)*deltaUT(m,nvrt) + psi0(m,nvrt-1), 2.0_rkind/dt*bigv_m(i,nvrt)*deltaUT(m,nvrt), deltaUT(m,nvrt)*term1))
            endif

            !update spatial limiter phi1, same formulation as phi0
            do k=kbe(i)+1,nvrt-1 !spatial gradient
                deltaUS(m,k)=tr_el(m,k+1,i)-tr_el(m,k,i)
                gradU(m,k)=deltaUS(m,k)/(ze(k+1,i)-ze(k-1,i))*2.0/area(i)
            enddo
            do k=kbe(i)+2,nvrt-1 
                !The selection of TVD spatial limiters will be given a parameter in the future
                !--------Van Leer---------
                !term1=gradU(m,k)*flux_adv_vface(k,i)*gradU(m,k-1)*flux_adv_vface(k-1,i)
                !term2=gradU(m,k)*flux_adv_vface(k,i)+gradU(m,k-1)*flux_adv_vface(k-1,i)
                !phi1(m,k)=(1.0_rkind+sign(1.0_rkind,term1))*term1/ &
                !    sign(max(abs(term2),epsilon(term2)),term2)

                !--------Minmod---------
                !term1=gradU(m,k)*flux_adv_vface(k,i)*bigv_m(i,k)
                !term2=gradU(m,k-1)*flux_adv_vface(k-1,i)*bigv_m(i,k-1)
                if ( flux_adv_vface(k,i)*flux_adv_vface(k-1,i)<0 ) then
                    phi1(m,k)=0.0
                elseif (flux_adv_vface(k,i)>0) then  !upward
                    term1=gradU(m,k)*flux_adv_vface(k,i)*bigv_m(i,k)
                    term2=gradU(m,k-1)*flux_adv_vface(k-1,i)*bigv_m(i,k-1)
                    phi1(m,k)= 0.5*(sign(1.0_rkind,term1)+sign(1.0_rkind,term2))  * min(abs(term1),abs(term2))
                else !downward
                    term1=gradU(m,k)*flux_adv_vface(k,i)*bigv_m(i,k+1)
                    term2=gradU(m,k-1)*flux_adv_vface(k-1,i)*bigv_m(i,k)
                    phi1(m,k)= 0.5*(sign(1.0_rkind,term1)+sign(1.0_rkind,term2))  * min(abs(term1),abs(term2))
                endif

                !--------Superbee---------
                !term1=gradU(m,k)*gradU(m,k-1)
                !term2=gradU(m,k)/sign(max(abs(gradU(m,k-1)),epsilon(gradU(m,k-1))),gradU(m,k-1))
                !phi1(m,k)=0.5*(1.0+sign(1.0,term1))*gradU(m,k-1)*max(min(2.0*term2,1.0),min(term2,1.0))
            enddo
            phi1(1:ntr,1:kbe(i)+1)=0.0_rkind
            phi1(1:ntr,nvrt)=0.0_rkind
        endif
          
        !TVD modification on face values
        !face(:,k) is defined on k+1/2, i.e. between (tr_el(:,k+1,:) and tr_el(:,k,:)
        do k=kbe(i)+1,nvrt-1
            faceL(m,k)=+0.5*phi1(m,k)
            faceLT(m,k)=-0.5*psi1(m,k)
            faceR(m,k)=-0.5*phi1(m,k+1)
            faceRT(m,k)=-0.5*psi1(m,k+1)
        enddo
        !surface, phi=0, only psi 
        faceL(m,nvrt)=0.0
        faceLT(m,nvrt)=-0.5*psi1(m,nvrt)
        faceR(m,nvrt)=0.0
        faceRT(m,nvrt)=0.0
        !bottom, phi=0, only psi 
        faceR(m,kbe(i))=0.0
        faceRT(m,kbe(i))=-0.5*psi1(m,kbe(i)+1)
        faceL(m,kbe(i))=0.0
        faceLT(m,kbe(i))=0.0

        !assemble rrhs (residual terms)
        do k=kbe(i)+1,nvrt
          kin=k-kbe(i) 
          !upwind part, only considering inflow
          if (flux_adv_vface(k-1,i)>0 .and. k>kbe(i)+1) then !k>kbe(i)+1, since tr_el(m,kbe(i),i) is not extended yet
              term1=flux_adv_vface(k-1,i)*(tr_el(m,k,i)-tr_el(m,k-1,i)) 
          else
              term1=0.0  
          endif
          if (flux_adv_vface(k,i)<0 .and. k<nvrt) then  !k<nvrt, since tr_el(m,nvrt+1,i) is undefined
              term2=flux_adv_vface(k,i)*(tr_el(m,k,i)-tr_el(m,k+1,i)) !inflow
          else 
              term2=0.0 
          endif
          !vertical diffusion
          if (k==kbe(i)+1) then
              term6=0.0 !bottom
          else
              term6=deltaUS(m,k-1)
          endif
          if (k==nvrt) then
              term5=0.0 !surface
          else
              term5=deltaUS(m,k)
          endif

          if (flux_adv_vface(k,i)>=0) then
              term3=faceL(m,k)+faceLT(m,k)
          else
              term3=faceR(m,k)+faceRT(m,k)
          endif
          if (flux_adv_vface(k-1,i)>=0) then
              term4=faceL(m,k-1)+faceLT(m,k-1)
          else
              term4=faceR(m,k-1)+faceRT(m,k-1)
          endif

          !residuals
          res(k)=tr_el(m,k,i)-trel_tmp(m,k,i)+ dt/bigv_m(i,k)*  &
          ( &
               +(term1-term2)  &  !upwind part
               +(term3-term4)  &  !TVD part 
               +(-v_diff(k,i)*term5 + v_diff(k-1,i)*term6) &  !vertical diffusion, horizontal diffusion not included yet
          )

        enddo !k=kbe(i)+1,nvrt

        !check convergence based on residuals
        temp=sqrt(sum(res(kbe(i)+1:nvrt)**2))
	    if ( temp < conv) then
            !write(*,*) "converges after tolf", iterK-1
            !iterN=iterN+iterK-1
            iConv(m)=0
            cycle !tracer loop
	    end if

        !add current tracer to rrhs, flux_sf and flux_bt not included yet
        rrhs(m,1:ndim)=-res(kbe(i)+1:nvrt)

        !-----------------------------------------------------------------------------
        enddo !tracers
        !-----------------------------------------------------------------------------

        if (sum(iConv)==0) then !all tracers converge
            exit !iteration loop
        endif

        !Note: soln is the increment of T, i.e (next step)-(this step)
        call tridag(nvrt,ntr,ndim,ntr,alow,bdia,cupp,rrhs,soln,gam)

        !update concentration
        do m=1,ntr
            if (iConv(m)==0) cycle
            tr_el(m,kbe(i)+1:nvrt,i)=tr_el(m,kbe(i)+1:nvrt,i)+soln(m,1:ndim)
        enddo

        !check convergence, based on increment
        do m=1,ntr
            if (iConv(m)==0) cycle
            temp=sqrt(sum(soln(m,1:ndim)**2))/sqrt(sum(tr_el(m,kbe(i)+1:nvrt,i)**2))
            if (temp<conv) then
                !write(*,*) "converges after TOTX", iterK
                !iterN=iterN+iterK
                iConv(m)=0
            endif   
        enddo
        if (sum(iConv)==0) then !all tracers converge
            exit
        endif

#ifdef RECORD_ITER
        if (iterK>iterK_MAX) then
            iterK_MAX=iterK
            iele_max=i
        endif   
#endif /*RECORD_ITER*/

        !-----------------------------------------------------------------------------
        enddo ! iterations
        !-----------------------------------------------------------------------------

        do k=kbe(i)+1,nvrt
          kin=k-kbe(i)

          if(imod==0) then !ST
            !tr_el(m,k,i)=soln(1,kin)
            if(ihconsv/=0) tr_el(1,k,i)=max(tempmin,min(tempmax,tr_el(1,k,i)))
            if(isconsv/=0) tr_el(2,k,i)=max(saltmin,min(saltmax,tr_el(2,k,i)))
          else !other tracers
#ifdef USE_NAPZD
!           CSD prevent bio from going negative here
!           CSD and collect bio deficit
!Bug: NBT not known here; also 1st index of tr_el wrong
            !do ibio=1,NBT
            do ibio=1,ntr
              !Here tr_el is already updated
              Bio_bdef(k,i)=Bio_bdef(k,i)+max(tr_el(ibio,k,i),0.d0)-tr_el(ibio,k,i)
              tr_el(ibio,k,i)=max(tr_el(ibio,k,i),0.d0)
            enddo
#else      
            !tr_el(m,k,i)=soln(m,kin)

#ifdef USE_SED
            do j=1,ntr
              if(tr_el(j,k,i).lt. -1.0E-20) then
!                     write(12,*)'negative sediment',i,k,tr_el(j,k,i)
                tr_el(j,k,i)=0.d0
              endif
            enddo
#endif /*USE_SED*/
#endif /*USE_NAPZD*/

          endif !imod
        enddo !k

!       Extend
        do k=1,kbe(i)
          tr_el(:,k,i)=tr_el(:,kbe(i)+1,i)
        enddo !k


      enddo !i=1,ne

#ifdef Out_Courant
        close (66)
       ! pause
#endif

#ifdef RECORD_ITER
      write(*,*) "max iterations at step ", it, ": ", iterK_MAX, "; element: ",iele_max
      iterK_MAX=0; iele_max=-1
#endif /*RECORD_ITER*/

!     Update ghosts
#ifdef INCLUDE_TIMING
      cwtmp=mpi_wtime()
      timer_ns(1)=timer_ns(1)+cwtmp-cwtmp2
#endif
      if(up_tvd) then !extend to 2-tier aug.
        call exchange_e3d_2t_tr(tr_el)
      else !pure upwind
        call exchange_e3d_tr(tr_el)
      endif
#ifdef INCLUDE_TIMING
      cwtmp2=mpi_wtime()
      wtimer(9,2)=wtimer(9,2)+cwtmp2-cwtmp
#endif      

!     Output warning for diffusion number
!      if(difnum_max_l>0.5) write(12,*)'Transport: diffusion # exceeds 0.5:',it,imod,difnum_max_l
!'

!     Deallocate temp. arrays
      deallocate(trel_tmp, &
               flux_adv_hface, &
               flux_mod_hface,flux_mod_vface, &
               up_rat_hface, &
               gradU,deltaUS,deltaUT,omega,u_p,psi0,psi1, &
               phi0,phi1,r_s,w_r, &
               faceL,faceR,bigv_m,res, &
               v_diff,iConv)

      end subroutine do_transport_tvd_imp
=======
!...  Fei: below is an e.g. of implicit upwind -feel free to add arrays if needed   
   
#ifdef Out_Courant   
      !Debug: file recording the vertical courant number at each element   
      open(66,file='courant',status='replace')   
#endif   
   
      do i=1,ne   
        if(idry_e(i)==1) cycle   
   
!       Wet elements with 3 wet nodes   
        n1=elnode(1,i)   
        n2=elnode(2,i)   
        n3=elnode(3,i)   
   
        iConv=-1 !all tracers set to -1 (not converged) initially   
   
        !temporal limiter set to 0 before the first iteration, which will be updated after each iteration   
        psi0=0   
   
        !--------------------Parameters that do not change through iterations------------------   
        !spatial limiter from the previous time step, not updated through iterations   
        do k=kbe(i)+1,nvrt-1    
            !spatial gradient = dT/dV, note that dV is not the volume of the prism,   
            !but between prism centers where T is defined   
            deltaUS(1:ntr,k)=trel_tmp(1:ntr,k+1,i)-trel_tmp(1:ntr,k,i)   
            gradU(1:ntr,k)=deltaUS(1:ntr,k)/(ze(k+1,i)-ze(k-1,i))*2.0/area(i)   
        enddo   
        do k=kbe(i)+2,nvrt-1   
            do m=1,ntr   
                !The selection of TVD spatial limiters will be given a parameter in the future   
                !---------Van Leer-----------   
                !term1=gradU(m,k)*gradU(m,k-1)   
                !term2=gradU(m,k)+gradU(m,k-1)   
                !phi0(m,k)=(1.0_rkind+sign(1.0_rkind,term1))*term1/ &   
                !    sign(max(abs(term2),epsilon(term2)),term2)   
   
                !---------Minmod-----------   
                phi0(m,k)= 0.5*(sign(1.0_rkind,gradU(m,k))+sign(1.0_rkind,gradU(m,k-1))) &   
                    * min(abs(gradU(m,k)),abs(gradU(m,k-1)))   
   
                !---------Superbee-----------   
                !term1=gradU(m,k)*gradU(m,k-1)   
                !term2=gradU(m,k)/sign(max(abs(gradU(m,k-1)),epsilon(gradU(m,k-1))),gradU(m,k-1))   
                !phi0(m,k)=0.5*(1.0+sign(1.0,term1))*gradU(m,k-1)*max(min(2.0*term2,1.0),min(term2,1.0))   
            enddo      
        enddo      
        !Caution: phi=0 at surface (nvrt) and bottom (kbe(i)+1), as well as extended levels      
        phi0(1:ntr,1:kbe(i)+1)=0.0_rkind      
        phi0(1:ntr,nvrt)=0.0_rkind      
      
!       Vertical diffusive flux      
        v_diff(kbe(i),i)=0.0 !bottom      
        v_diff(nvrt,i)=0.0 !surface      
        do k=kbe(i)+1,nvrt-1      
          av_df=(dfh1(k,n1)+dfh1(k,n2)+dfh1(k,n3))/3 !diffusivity      
          av_dz=(ze(k+1,i)-ze(k-1,i))/2.d0      
          v_diff(k,i)=area(i)*av_df/av_dz      
        enddo      
                
        !debug: set vertical diffusion to 0 temporarily      
        !v_diff=0.0      
      
        !r_s (local Courant number), only used for determining temporal limiter psi      
        do k=kbe(i)+1,nvrt      
            r_s(k)=dt/bigv_m(i,k)*sign(max(abs(flux_adv_vface(k,i)),abs(flux_adv_vface(k-1,i))), &       
                flux_adv_vface(k,i)+flux_adv_vface(k-1,i) )      
        enddo      
#ifdef Out_Courant      
        r_s0(kbe(i)+1:nvrt)=abs(r_s(kbe(i)+1:nvrt))      
        r_s0(kbe(i))=maxval(r_s0(kbe(i)+1:nvrt))      
        write(66,"(27F19.7)") (xnd(n1)+xnd(n2)+xnd(n3))/3.0, (ynd(n1)+ynd(n2)+ynd(n3))/3.0, r_s0      
#endif      
      
        !Matrix, including advective flux and diffusive flux      
        ndim=nvrt-kbe(i) !# of eqs/unknowns      
        alow=0; bdia=1; cupp=0      
        do k=kbe(i)+1,nvrt      
          kin=k-kbe(i)       
          dt_by_bigv = dt/bigv_m(i,k)      
          if(k<nvrt) then      
            tmp=dt_by_bigv*v_diff(k,i)      
            cupp(kin)=cupp(kin)-tmp      
            bdia(kin)=bdia(kin)+tmp      
      
            !Upwind advection      
            tmp=abs(flux_adv_vface(k,i))*dt_by_bigv       
            if(flux_adv_vface(k,i)<0) then !downward inflow      
              cupp(kin)=cupp(kin)-tmp      
              bdia(kin)=bdia(kin)+tmp      
            endif       
          endif !k<nvrt      
      
          if(k>kbe(i)+1) then      
            tmp=dt_by_bigv*v_diff(k-1,i)      
            alow(kin)=alow(kin)-tmp      
            bdia(kin)=bdia(kin)+tmp      
      
            tmp=abs(flux_adv_vface(k-1,i))*dt_by_bigv      
            if(flux_adv_vface(k-1,i)>0) then !upward inflow      
              alow(kin)=alow(kin)-tmp      
              bdia(kin)=bdia(kin)+tmp      
            endif      
          endif !k>kbe(i)+1      
      
        enddo      
        !--------------------End: parameters that do not change through iterations------------------      
      
!--------------------------------------------------------------------------------------------------------      
        do iterK=1,itmax !cycle through iterations      
        do m=1,ntr !cycle through tracers.      
        !Tracer loop is placed inside iteration loop to apply tridag efficiently,      
        !although not all tracers converge at the same time, iConv is used to      
        !monitor convergence of each tracer      
!-----------------------------start iterations-----------------------------------------------------------      
      
        if (iConv(m)==0) cycle !already converged      
      
        if (iterK==1) then !first iteration, use initial phi and psi      
            phi1(m,:)=phi0(m,:) !spatial limiter      
            psi1(m,:)=psi0(m,:) !temporal limiter      
        else      
            !this iteration's psi0 is last iteration's psi1      
            psi0(m,:)=psi1(m,:)        
            !update temporal limiter      
            deltaUT=tr_el(1:ntr,:,i)-trel_tmp(1:ntr,:,i) !temporal increment   
            do k=kbe(i)+1,nvrt   
                if (deltaUT(m,k)>=0) then   
                    psi1(m,k)=max(0.0_rkind,min(2.0_rkind/r_s(k)*deltaUT(m,k) + psi0(m,k-1), deltaUT(m,k)))   
                else   
                    psi1(m,k)=min(0.0_rkind,max(2.0_rkind/r_s(k)*deltaUT(m,k) + psi0(m,k-1), deltaUT(m,k)))   
                endif   
            enddo   
   
            !update spatial limiter phi1, same formulation as phi0   
            do k=kbe(i)+1,nvrt-1 !spatial gradient   
                deltaUS(m,k)=tr_el(m,k+1,i)-tr_el(m,k,i)   
                gradU(m,k)=deltaUS(m,k)/(ze(k+1,i)-ze(k-1,i))*2.0/area(i)   
            enddo   
            do k=kbe(i)+2,nvrt-1    
                !The selection of TVD spatial limiters will be given a parameter in the future   
                !--------Van Leer---------   
                !term1=gradU(m,k)*gradU(m,k-1)   
                !term2=gradU(m,k)+gradU(m,k-1)   
                !phi1(m,k)=(1.0_rkind+sign(1.0_rkind,term1))*term1/ &   
                !    sign(max(abs(term2),epsilon(term2)),term2)   
   
                !--------Minmod---------   
                phi1(m,k)= 0.5*(sign(1.0_rkind,gradU(m,k))+sign(1.0_rkind,gradU(m,k-1))) &   
                    * min(abs(gradU(m,k)),abs(gradU(m,k-1)))   
   
                !--------Superbee---------   
                !term1=gradU(m,k)*gradU(m,k-1)   
                !term2=gradU(m,k)/sign(max(abs(gradU(m,k-1)),epsilon(gradU(m,k-1))),gradU(m,k-1))   
                !phi1(m,k)=0.5*(1.0+sign(1.0,term1))*gradU(m,k-1)*max(min(2.0*term2,1.0),min(term2,1.0))   
            enddo   
            phi1(1:ntr,1:kbe(i)+1)=0.0_rkind   
            phi1(1:ntr,nvrt)=0.0_rkind   
        endif   
             
        !TVD modification on face values   
        !face(:,k) is defined on k+1/2, i.e. between (tr_el(:,k+1,:) and tr_el(:,k,:)   
        do k=kbe(i)+1,nvrt-1   
            faceL(m,k)=+0.5*phi1(m,k)*bigv_m(i,k)-0.5*psi1(m,k)   
            faceR(m,k)=-0.5*phi1(m,k+1)*bigv_m(i,k+1)-0.5*psi1(m,k+1)   
        enddo   
        !surface, phi=0, only psi    
        faceL(m,nvrt)=-0.5*psi1(m,nvrt)   
        faceR(m,nvrt)=0.0   
        !bottom, phi=0, only psi    
        faceR(m,kbe(i))=-0.5*psi1(m,kbe(i)+1)   
        faceL(m,kbe(i))=0.0   
   
        !assemble rrhs (residual terms)   
        do k=kbe(i)+1,nvrt   
          kin=k-kbe(i)    
          !upwind part, only considering inflow   
          if (flux_adv_vface(k-1,i)>0 .and. k>kbe(i)+1) then !k>kbe(i)+1, since tr_el(m,kbe(i),i) is not extended yet   
              term1=flux_adv_vface(k-1,i)*(tr_el(m,k,i)-tr_el(m,k-1,i))    
          else   
              term1=0.0     
          endif   
          if (flux_adv_vface(k,i)<0 .and. k<nvrt) then  !k<nvrt, since tr_el(m,nvrt+1,i) is undefined   
              term2=flux_adv_vface(k,i)*(tr_el(m,k,i)-tr_el(m,k+1,i)) !inflow   
          else    
              term2=0.0    
          endif   
          !vertical diffusion   
          if (k==kbe(i)+1) then   
              term6=0.0 !bottom   
          else   
              term6=deltaUS(m,k-1)   
          endif   
          if (k==nvrt) then   
              term5=0.0 !surface   
          else   
              term5=deltaUS(m,k)   
          endif   
   
          !residuals   
          res(k)=tr_el(m,k,i)-trel_tmp(m,k,i)+ dt/bigv_m(i,k)*  &   
          ( &   
                (term1-term2)  &  !upwind part   
                +0.5* ( &  !TVD part   
                + (flux_adv_vface(k,i)+abs(flux_adv_vface(k,i)))*faceL(m,k) &   
                - (flux_adv_vface(k-1,i)+abs(flux_adv_vface(k-1,i)))*faceL(m,k-1) &   
                - (flux_adv_vface(k-1,i)-abs(flux_adv_vface(k-1,i)))*faceR(m,k-1)   &   
                + (flux_adv_vface(k,i)-abs(flux_adv_vface(k,i)))*faceR(m,k)  &   
                ) &   
                + (  & !vertical diffusion, horizontal diffusion not included yet   
                  - v_diff(k,i)*term5 &   
                  + v_diff(k-1,i)*term6 &   
                ) &   
           )   
   
        enddo !k=kbe(i)+1,nvrt   
   
        !check convergence based on residuals   
        temp=sqrt(sum(res(kbe(i)+1:nvrt)**2))   
	    if ( temp < conv) then   
            !write(*,*) "converges after tolf", iterK-1   
            !iterN=iterN+iterK-1   
            iConv(m)=0   
            cycle !tracer loop   
	    end if   
   
        !add current tracer to rrhs, flux_sf and flux_bt not included yet   
        rrhs(m,1:ndim)=-res(kbe(i)+1:nvrt)   
   
        !-----------------------------------------------------------------------------   
        enddo !tracers   
        !-----------------------------------------------------------------------------   
   
        if (sum(iConv)==0) then !all tracers converge   
            exit !iteration loop   
        endif   
   
        !Note: soln is the increment of T, i.e (next step)-(this step)   
        call tridag(nvrt,ntr,ndim,ntr,alow,bdia,cupp,rrhs,soln,gam)   
   
        !update concentration   
        do m=1,ntr   
            if (iConv(m)==0) cycle   
            tr_el(m,kbe(i)+1:nvrt,i)=tr_el(m,kbe(i)+1:nvrt,i)+soln(m,1:ndim)   
        enddo   
   
        !check convergence, based on increment   
        do m=1,ntr   
            if (iConv(m)==0) cycle   
            temp=sqrt(sum(soln(m,1:ndim)**2))/sqrt(sum(tr_el(m,kbe(i)+1:nvrt,i)**2))   
            if (temp<conv) then   
                !write(*,*) "converges after TOTX", iterK   
                !iterN=iterN+iterK   
                iConv(m)=0   
            endif      
        enddo   
        if (sum(iConv)==0) then !all tracers converge   
            exit   
        endif   
   
#ifdef RECORD_ITER   
        if (iterK>iterK_MAX) then   
            iterK_MAX=iterK   
            iele_max=i   
        endif      
#endif /*RECORD_ITER*/   
   
        !-----------------------------------------------------------------------------   
        enddo ! iterations   
        !-----------------------------------------------------------------------------   
   
        do k=kbe(i)+1,nvrt   
          kin=k-kbe(i)   
   
          if(imod==0) then !ST   
            !tr_el(m,k,i)=soln(1,kin)   
            if(ihconsv/=0) tr_el(1,k,i)=max(tempmin,min(tempmax,tr_el(1,k,i)))   
            if(isconsv/=0) tr_el(2,k,i)=max(saltmin,min(saltmax,tr_el(2,k,i)))   
          else !other tracers   
#ifdef USE_NAPZD   
!           CSD prevent bio from going negative here   
!           CSD and collect bio deficit   
!Bug: NBT not known here; also 1st index of tr_el wrong   
            !do ibio=1,NBT   
            do ibio=1,ntr   
              !Here tr_el is already updated   
              Bio_bdef(k,i)=Bio_bdef(k,i)+max(tr_el(ibio,k,i),0.d0)-tr_el(ibio,k,i)   
              tr_el(ibio,k,i)=max(tr_el(ibio,k,i),0.d0)   
            enddo   
#else         
            !tr_el(m,k,i)=soln(m,kin)   
   
#ifdef USE_SED   
            do j=1,ntr   
              if(tr_el(j,k,i).lt. -1.0E-20) then   
!                     write(12,*)'negative sediment',i,k,tr_el(j,k,i)   
                tr_el(j,k,i)=0.d0   
              endif   
            enddo   
#endif /*USE_SED*/   
#endif /*USE_NAPZD*/   
   
          endif !imod   
        enddo !k   
   
!       Extend   
        do k=1,kbe(i)   
          tr_el(:,k,i)=tr_el(:,kbe(i)+1,i)   
        enddo !k   
   
   
      enddo !i=1,ne   
   
#ifdef Out_Courant   
        close (66)   
       ! pause   
#endif   
   
#ifdef RECORD_ITER   
      write(*,*) "max iterations at step ", it, ": ", iterK_MAX, "; element: ",iele_max   
      iterK_MAX=0; iele_max=-1   
#endif /*RECORD_ITER*/   
   
!     Update ghosts   
#ifdef INCLUDE_TIMING   
      cwtmp=mpi_wtime()   
      timer_ns(1)=timer_ns(1)+cwtmp-cwtmp2   
#endif   
      call exchange_e3d_tr(tr_el)   
#ifdef INCLUDE_TIMING   
      cwtmp2=mpi_wtime()   
      wtimer(9,2)=wtimer(9,2)+cwtmp2-cwtmp   
#endif         
   
!     Output warning for diffusion number   
!      if(difnum_max_l>0.5) write(12,*)'Transport: diffusion # exceeds 0.5:',it,imod,difnum_max_l   
!'   
   
!     Deallocate temp. arrays   
      deallocate(trel_tmp, &   
               flux_adv_hface, flux_adv_vface, &   
               flux_mod_hface,flux_mod_vface, &   
               up_rat_hface,up_rat_vface, &   
               gradU,deltaUS,deltaUT,omega,u_p,psi0,psi1, &   
               phi0,phi1,r_s,w_r, &   
               faceL,faceR,bigv_m,res, &   
               v_diff,iConv)   
   
      end subroutine do_transport_tvd_imp   
>>>>>>> 8b58d170a780f99abe62a58205e9ea8e1db083a7
