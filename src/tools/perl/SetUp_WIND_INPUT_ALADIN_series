#!/usr/bin/perl -w

use POSIX qw(ceil floor);

use strict;
use warnings;



#
# Beginning of section on time functions
#

sub round {
    my($number) = shift;
    return int($number + .5);
}

sub fix {
    my($number) = shift;
    if ($number > 0)
    {
        return floor($number);
    }
    else
    {
        return -floor(-$number);
    }
}

sub num2strPerso {
    my($number) = shift;
    my $rndA=round($number);
    if ($rndA < 10)
    {
        return "0".$rndA;
    }
    else
    {
        return $rndA;
    }
}

sub IsBissextile {
    my($number) = shift;
    my $rnd1=round($number/4);
    if (4*$rnd1 eq $number)
    {
        if ($number eq 1900)
        {
            return 0;
        }
        if ($number eq 2000)
        {
            return 1;
	}
        if ($number eq 2100)
        {
            return 0;
        }
        return 1;
    }
    else
    {
        return 0;
    }
}

sub Freduction($$)
{
    my ($val1, $val2) = @_;
    if ($val1 eq "0")
    {
        return $val2;
    }
    else
    {
        return $val1.$val2;
    }
}

sub mjd2date($)
{
    my ($nbDay)=@_;
    my $jd=$nbDay+2440000-0.5;

    my $ijd=floor($jd + 0.5);
    my $fjd=$jd - $ijd + 0.5;

    my $days=$fjd;

    my $second = 86400 * $days;
    my $hour   = fix($second/3600);
    $second = $second - 3600*$hour;
    my $minute = fix($second/60);
    $second = $second - 60*$minute;

    my $a = $ijd + 32044;
    my $b = floor((4 * $a + 3) / 146097);
    my $c = $a - floor(($b * 146097) / 4);

    my $d = floor((4 * $c + 3) / 1461);
    my $e = $c - floor((1461 * $d) / 4);
    my $m = floor((5 * $e + 2) / 153);

    my $day   = $e - floor((153 * $m + 2) / 5) + 1;
    my $month = $m + 3 - 12 * floor($m / 10);
    my $year  = $b * 100 + $d - 4800 + floor($m / 10);
    return ($year, $month, $day, $hour, $minute, $second);
}

sub date2mjd($$$$$$)
{
    my ($year, $month, $day, $hour, $minute, $second)=@_;
    my $a = floor((14 - $month)/12);
    my $y = $year + 4800 - $a;
    my $m = $month + 12*$a - 3;
    my $jd = $day + floor((153*$m + 2)/5) + $y*365 + floor($y/4) - floor($y/100) + floor($y/400) - 32045 + ( $second + 60*$minute + 3600*($hour - 12) )/86400;
    my $mjd=$jd-2400000.5;
    return $mjd;
}

sub persoDate2mjd($$$$$$)
{
    my ($year, $month, $day, $hour, $minute, $second)=@_;
    my $VAL1=date2mjd($year, $month, $day, $hour, $minute, $second);
    my $VAL2=date2mjd(1968, 5, 23,   0, 0, 0);
    my $VAL3=$VAL1-$VAL2;
    return $VAL3;
}

sub WWM_stringTime($)
{
    my ($eDayMJD) = @_;
    (my $eYear, my $eMonth, my $eDay, my $eHour, my $eMin, my $eSec)=mjd2date($eDayMJD);
    my $strYear=$eYear;
    my $strMonth=num2strPerso($eMonth);
    my $strDay=num2strPerso($eDay);
    my $strHour=num2strPerso($eHour);
    my $strMin=num2strPerso($eMin);
    my $strSec=num2strPerso($eSec);
    my $strRet=$strYear.$strMonth.$strDay.".".$strHour.$strMin.$strSec;
    return $strRet;
}


sub ALADIN_pathTime($)
{
    my ($eDayMJD) = @_;
    (my $eYear, my $eMonth, my $eDay, my $eHour, my $eMin, my $eSec)=mjd2date($eDayMJD);
    my $strYear=$eYear;
    my $strMonth=num2strPerso($eMonth);
    my $strDay=num2strPerso($eDay);
    my $strHour=num2strPerso($eHour);
    my $strMin=num2strPerso($eMin);
    my $strSec=num2strPerso($eSec);
    my $strRet=$strYear.$strMonth.$strDay."_".$strHour;
    return $strRet;
}



sub GetLineOption($)
{
    my ($strIn) = @_;
    my @VSR=split("", $strIn);
    my $nbChar=scalar(@VSR);
    #
    my $strRed="";
    my $HaveEq=0;
    for (my $iChar=0; $iChar<$nbChar; $iChar++)
    {
	my $eChar=$VSR[$iChar];
	if ($eChar eq "=")
	{
	    $HaveEq=1;
	}
	if ($eChar ne " " && $HaveEq eq 0)
	{
	    $strRed=$strRed.$eChar;
	}
    }
    if ($HaveEq eq 0)
    {
	return "zorglub";
    }
    return $strRed;
}

sub ExtractNamelistSection($)
{
    my ($strIn) = @_;
    $_=$strIn;
    s/ //g;
    my $strIn2=$_;
    my @U=split("", $strIn2);
    if ($U[0] eq "&")
    {
	my $strRet1="";
	for (my $iChar=1; $iChar<scalar(@U); $iChar++)
	{
	    $strRet1=$strRet1.$U[$iChar];
	}
	return $strRet1;
    }
    return "zorglub";
}

#
# The normal code
#

my $uu=scalar(@ARGV);
if ($uu ne 4)
{
    print "SetUp_WIND_INPUT_series is used as\n";
    print "SetUp_WIND_INPUT_series starttime methodology [PATH_IN] [FILE_OUT]\n";
    print "Format of StartTime is as in DHMZ: YYYYMMDD_HH\n";
    print "If starttime=current then current time is used (for operational)\n";
    print "     otherwise, we use the time expressed as YYYMMDD\n";
    print "methodology can take the form of\n";
    print "   DHMZ : for the DHMZ method of organizing as YYYYMMDD_HH directories\n";
    print "    RAW : for the IRB method of having all the files in disorder\n";
    die;
}


my $starttime=$ARGV[0];
my $methodology=$ARGV[1];
my $PathIn=$ARGV[2];
my $FileOut=$ARGV[3];

print "starttime=".$starttime."\n";
print "PATH_IN=".$PathIn."\n";
print "FileOut=".$FileOut."\n";

#
# time determination
#

sub Get_StartTimeMJD($)
{
    my ($strDate) = @_;
    my @U=split("", $strDate);
    my $year=$U[0].$U[1].$U[2].$U[3];
    my $month=$U[4].$U[5];
    my $day=$U[6].$U[7];
    my $hour=0;
    my $minute=0;
    my $second=0;
    my $StartTimeMJD=persoDate2mjd($year, $month, $day, $hour, $minute, $second);
    print "strDate=".$strDate." StartTimeMJD=".$StartTimeMJD."\n";
    return $StartTimeMJD;
}

my $TimeSearchMJD;
if ($starttime eq "current")
{
    my $strDate = `date -u +%Y%m%d`;
    my $StartTimeMJD=Get_StartTimeMJD($strDate);
    $TimeSearchMJD=$StartTimeMJD - 1;
}
else
{
    my $strDate = $starttime;
    $TimeSearchMJD=Get_StartTimeMJD($strDate);
}

#
# Determination of the input
#

my @ListFileFull=();
my @ListFileNaked=();
my @ListTimeMJD=();
my @ListIspan=();
my @ListTimeState=();
my $nbFile=0;
my @ListEntriesByTime=();




sub SingleInsert_File($$$$$)
{
    my ($TimeSearchMJD, $iSpan, $FullPath, $FileNaked, $iPos) = @_;
    my $FullFileName=$FullPath.$FileNaked;
    my $eTimeState=$TimeSearchMJD + $iSpan/24;
    #
    $ListFileFull[$nbFile]=$FullFileName;
    $ListFileNaked[$nbFile]=$FileNaked;
    $ListTimeMJD[$nbFile]=$TimeSearchMJD;
    $ListIspan[$nbFile]=$iSpan;
    $ListTimeState[$nbFile]=$eTimeState;
    #
    my $len=scalar(@ListEntriesByTime);
    if ($iPos >= $len)
    {
	for (my $jPos=$len; $jPos<$iPos; $jPos++)
	{
	    $ListEntriesByTime[$jPos]="";
	}
	$ListEntriesByTime[$iPos]=$nbFile;
    }
    else
    {
	$ListEntriesByTime[$iPos]=$ListEntriesByTime[$iPos]." ".$nbFile;
    }
}



if ($methodology eq "DHMZ")
{
    my $nbHour=72;
    my $iShiftTime=0;
    while(1)
    {
	my $strWind=ALADIN_pathTime($TimeSearchMJD);
	print "Considering wind forecasts at strWind=".$strWind."\n";
	my $FullPath=$PathIn.$strWind."/";
	my $nbFileFound=0;
	#
	for (my $iSpan=0; $iSpan<=$nbHour; $iSpan++)
	{
	    my $FileNaked=$strWind."_hr22+".num2strPerso($iSpan).".grb";
	    my $FullFileName=$FullPath.$FileNaked;
	    if (-e $FullFileName)
	    {
		my $iPos=$iShiftTime + $iSpan;
		SingleInsert_File($TimeSearchMJD, $iSpan, $FullPath, $FileNaked, $iPos);
		#
		$nbFile++;
		$nbFileFound++;
	    }
	}
	if ($nbFileFound eq 0)
	{
	    last;
	}
	$TimeSearchMJD=$TimeSearchMJD + 0.5;
	$iShiftTime = $iShiftTime + 12;
    }
}
else
{
    opendir(DIR, $PathIn);
    while(my $file = readdir(DIR)) {
	next if ($file eq ".");
	next if ($file eq "..");
	print "file=".$file."\n";
	my @USL=split("_hr", $file);
	my $part0=$USL[0];
	my $part1=$USL[1];
	print "part0=".$part0." part1=".$part1."\n";
	my @USL2=split("", $part1);
	#
	my @USL3=split("", $part0);
	my $year=$USL3[0].$USL3[1].$USL3[2].$USL3[3];
	my $month=$USL3[4].$USL3[5];
	my $day=$USL3[6].$USL3[7];
	my $hour=$USL3[9].$USL3[10];
	my $minute=0;
	my $second=0;
	my $TimeFoundMJD=persoDate2mjd($year, $month, $day, $hour, $minute, $second);
	#
	my $iSpan=$USL2[3].$USL2[4];
	my $FileNaked=$file;
	my $FullPath=$PathIn;
	print "TimeSearchMJD=".$TimeSearchMJD." TimeFoundMJD=".$TimeFoundMJD." iSpan=".$iSpan."\n";
	my $iPos=24*($TimeFoundMJD - $TimeSearchMJD) + $iSpan;
	if ($iPos >= 0)
	{
	    SingleInsert_File($TimeSearchMJD, $iSpan, $FullPath, $FileNaked, $iPos);
	    $nbFile++;
	}
    }
    closedir(DIR);
}


#
# Now iterating and making everything works
#

open(OUT, "> ".$FileOut);
my $nbEntries=scalar(@ListEntriesByTime);
print "nbEntries=".$nbEntries."\n";
for (my $iEntries=0; $iEntries<$nbEntries; $iEntries++)
{
    my $strEntriesByTime=$ListEntriesByTime[$iEntries];
    my @U=split(" ", $strEntriesByTime);
    my $nbU=scalar(@U);
    print "iEntries=".$iEntries." strEntriesByTime=".$strEntriesByTime." nbU=".$nbU."\n";
    if ($nbU > 0)
    {
	my $iFileBest=-1;
	my $PenaltyMin=4000;
	for (my $iU=0; $iU<$nbU; $iU++)
	{
	    my $iFile=$U[$iU];
	    my $iSpan=$ListIspan[$iFile];
	    my $Penalty=abs($iSpan - 24);
	    if ($iFileBest ne -1)
	    {
		if ($iSpan >= 6 && $iSpan <= 30)
		{
		    if ($Penalty < $PenaltyMin)
		    {
			$iFileBest=$iFile;
		    }
		}
	    }
	    else
	    {
		$iFileBest=$iFile;
	    }
	}
	if ($iFileBest ne -1)
	{
	    my $FullFile=$ListFileFull[$iFileBest];
	    my $FileNaked=$ListFileNaked[$iFileBest];
	    my $order="ln -sf ".$FullFile;
	    if (system($order) != 0) {
		die "Error while creating the link";
	    }
	    print OUT $FileNaked."\n";
	}
    }
}
close(OUT);
